[{"content":"01. 상속과 중복 코드 # DRY 원칙 # 중복 코드는 변경을 방해한다. 중복코드는 코드를 수정하는 데 필요한 노력을 몇 배로 증가 시킨다. 어떤 코드가 중복인지 찾고, 중복 코드의 묶음을 찾았다면 찾아낸 모든 코드를 일관되게 수정해야 한다. 모든 중복 코드는 개별적으로 테스트해서 동일한 결과는 내놓는지 확인해야 한다. 중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다. 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다. DRY (Don’t Repeat Yourself) 중복과 변경 # Call, NightlyDiscountPhone 예시(313p) 중복 코드는 새로운 중복코드를 부른다. 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은 새로운 중복 코드를 추가하는 것뿐이다. 새로운 중복코드를 추가하는 과정에서 코드의 일관성이 무너질 위험이 항상 도사리고 있다. 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다. 상속을 이용해서 중복 코드 제거하기 # 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각보다 쉽지 않다. 개발자는 재사용을 위해 상속 계층 사이에 무수히 많은 가정을 세웠을지도 모른다. 그 가정은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다. 요구사항과 구현 사이의 차이가 크면 클수록 코드를 이해하기 어려워진다. 실제 프로젝트에서 마주치게 될 클래스의 상속 계층은 매우 깊을 것이다. 깊고 깊은 상속 계층의 계단을 하나 내려올 때마다 이해하기 어려운 가정과 마주한다면? 상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다. 이는 자식 클래스 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다. 상속은 결합도를 높인다. 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다. 02. 취약한 기반 클래스 문제 # 상속은 자식 클래스와 부모 클래스의 결합도를 높인다. 이 강한 결합도로 인해 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 이처럼 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제라고 한다. 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다. 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다. 취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다. 불필요한 인터페이스 상속문제 # 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다. 자바의 Stack은 Vector 클래스를 상속한다. Stack에서 push가 아닌 Vector의 add 메서드를 사용하면 에러를 유발할 수 있음. (스택의 가장 뒤가 아닌 앞에 데이터가 추가됨) Stack을 사용하는 개발자들이 Vector에서 상속받은 메서드를 사용하지 않으면 된다고 생각할 수는 있다. 하지만 인터페이스는 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다. Stack 개발자 한 사람의 일시적인 편의를 위해 인터페이스를 사용해야 하는 무수한 사람들이 가슴을 졸여야 하는 상황을 초래하는 것은 정당화하기 어렵다. 메서드 오버라이딩의 오작용 문제 # 자식 클래스에서 메서드를 오버라이딩할 때, 부모 클래스의 다른 메서드에서 오버라이딩 하는 메서드를 호출하는지 파악해야 한다. 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다. 부모 클래스와 자식 클래스 동시 수정 문제 # 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 03. Phone 다시 살펴보기 # 추상화에 의존하자 # 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만들어라. 차이를 메서드로 추출하라 # 중복 코드 안에서 차이점은 별도의 메서드로 추출하라 ‘변하는 것으로부터 변하지 않는 것을 분리하라\u0026rsquo;, ‘변하는 부분을 찾고 이를 캡슐화하라\u0026rsquo; 라는 조언을 메서드 수준에서 적용한 것이다. 예시의 Phone, NightDiscountPhone의 경우 계산한 요금을 더하는 부분은 공통화하고, 계산하는 부분을 추출한다. 중복 코드를 부모 클래스로 올려라 # Phone과 NightlyDiscountPhone의 공통 부분을 부모 클래스로 이동시킨다. 동일한 메서드인 calculateFee는 추상 클래스로 이동하고, calculateCallFee만 자식클래스에서 각자 구현한다. 추상화가 핵심이다 # 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가지게 된다. AbstractPhone - 전체 통화 목록의 계산 방법이 변경되었을 때 Phone - 일반 요금제의 통화 한 건을 계산하는 방식이 변경되었을 때 NightlyDiscountPhone - 심야 할인 요금제의 통화 한 건을 계산하는 방식이 변경되었을 때 단일 책임 원칙 준수 클래스들이 추상화에 의존하기 때문에 의존성 역전 원칙도 준수하며, 새로운 요금제를 추가하기도 쉽다. 04. 차이에 의한 프로그래밍 # 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍이라고 부른다. 상속을 이용하면 이미 존재한느 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다. 차이에 의한 프로그래밍의 목표는 중복 코드를 재사용하는 것이다. 중복 코드 제거와 코드 재사용은 동일한 행동을 가리키는 서로 다른 단어다. 중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다. 코드를 재사용하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다. 따라서 중복 코드를 제거하기 위해 최대한 코드를 재사용해야 한다. 재사용 가능한 코드란 심각한 버그가 존재하지 않는 코드다. 코드를 재사용하면 코드의 품질은 유지하면서도 코드를 작성하는 노력과 테스트는 줄일 수 있다. 객체지향 세계에서 중복 코드를 제거하고 코드를 재사용할 수 있는 가장 유명한 방법은 상속이다. 하지만 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다. ","date":"2022 / 07 / 24","permalink":"/posts/study/object/object-10/","section":"Posts","summary":"오브젝트 10장 상속과 중복 코드","title":"오브젝트 10장 상속과 중복 코드"},{"content":"서론 # 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠뜨릴 수 있다. 협력은 객체가 다른 객체에 대해 알 것을 강요한다. 이런 지식은 객체 사이에 의존성을 낳는다. 협력을 위해서 의존성이 필요하지만, 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서 변경을 방해하는 의존성은 제거하는데 있다. 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다. 01. 의존성 이해하기 # 변경과 의존성 # 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 생긴다. 의존성은 실행 시점과 구현 시점에 다른 의미를 가진다. 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다. 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다. 의존성은 단방향이다. 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 의존성 전이 # 의존성은 전이 될 수 있다. 의존성은 함께 변경될 수 있는 가능성을 의미하며, 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다. 런타임 의존성과 컴파일타임 의존성 # 런타임 : 실행되는 시점\n컴파일 : 코드를 컴파일하는 시점이거나 문맥에 따라서는 코드 그 자체를 가리킴\n런타임 의존성이 다루는 주제는 객체사이의 의존성이며, 코드 관점에서 주인공은 클래스이다.\n여기서 중요한 것은 런타임 의존성과 컴파일 의존성이 다를 수 있다는 것이다.\n앞선 예제에서 DiscountPolicy와 같은 추상클래스와의 의존성이 컴파일 의존성이고, PercentDiscountPolicy, AmountDiscountPolicy와 같은 클래스 인스턴스와의 의존성은 런타임임.\n어떤 클래스의 인스턴스가 다양한 클래스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.\n실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다. 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다. 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 셜계가 유연해지고 재사용 가능해진다.\n컨텍스트 독립성 # 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서는 사용하기 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트 독립성이라고 부른다. 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대해 구체적인 정보를 최대한 적게 알아야 한다. 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다. 결과적으로 설계는 더 유연해지고 변경에 탄력적으로 대응할 수 있게 될 것이다. 의존성 해결하기 # 객체를 생성하는 시점에 생성자를 통해서 의존성 해결 객체 생성 후 setter 메서드를 통해 의존성 해결 메서드 실행 시 인자를 이용해 의존성 해결 02. 유연한 설계 # 의존성과 결합도 # 의존성은 객체들의 협력을 가능하게 만들지만, 과하면 문제가 될 수 있다. 예시 - 객체 인스턴스에 직접 의존 이 경우 의존성의 정도가 문제다. 꼭 특정 객체가 아니라 어떤 타입과의 객체와도 협력할 수 있도록 만들어야 함. 바람직한 의존성이란? 재사용과 관련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성을 바람직하지 못한 것이다. 컨텍스트에 독립적인 의존성이 바람직하며, 특정한 컨텍스트에 강하게 결합된 의존성은 바람직 하지 않다. 특정 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐이다. 개발 커뮤니티에서 바람직 하지 않은 의존성을 가리키는 다른 용어는 결합도이다. 두 요소 사이에 의존성이 바람직하다면 ‘느슨한 결합도’ 또는 ‘약한 결합도\u0026rsquo;라 부르고, 바람직 하지 못한다면 ‘단단한 결합도\u0026rsquo;, ‘강한 결합도\u0026rsquo;라고 부른다. 지식이 결합을 낳는다. # 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다. 다른 요소에 대해 더 많은 정보를 알고 있을 수록 두 요소는 강하게 결합된다. 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다. 기존 지식에 어울리지 않는 컨텍스트에서 클래스의 인스턴스를 사용하기 위해서 할 수 있는 유일한 방법은 클래스를 수정하는 것뿐이다. 결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 한다. 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다. 이 목적을 달성할 수 있는 가장 효과적인 방법은 추상화이다. 추상화에 의존하라 # 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다. 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. 따라서 대상에 대해 알아야 하는 지식의 양이 줄어들고 결합도는 느슨하게 유지된다. 추상화 결합도 관점에서 의존 대상을 다음과 같이 구분하면 유용하다 구체 클래스 의존성 추상 클래스 의존성 인터페이스 의존성 아래로 갈 수 록 알아야 하는 지식이 줄어든다. 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다. 명시적인 의존성 # 느슨한 결합도를 위해서는 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야 한다. 어떻게? 의존성을 해결하기 위해 추상클래스를 상속받거나 인터페이스를 실체화한 구체 클래스를 생성자, setter, 메서드 인자를 이용하여 전달하는 것이다. 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 설정할 수 있는 방법을 제공하는지 여부이다. 의존성을 명시적으로 퍼블릭 인터페이스에 노출하면 이를 명시적 의존성이라 부른다. 클래스 생성자 내에서 다른 객체를 직접 생성하는 경우 처럼 인터페이스에 드러나지 않는다면 숨겨진 의존성이라고 부른다. 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다. 커다란 클래스에 정의된 긴 메서드 내부 어딘가에서 인스턴스를 생성하는 코드를 파악하는 것은 쉽지 않다. 더 큰 문제는 다른 컨텍스트에서 재사용하기 위해서는 내부 구현을 직접 변경해야 한다는 것이다. 의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라. 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 선택할 수 있다. new는 해롭다. # new를 잘못쓰면 클래스 사이의 결합도가 극단적으로 높아진다.\nnew 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다. new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어난다. new의 해결 방법은 인스턴스를 생성하는 로직과 인스턴스를 사용하는 로직을 분리하는 것이다.\n사용과 생성의 책임을 분리하면 설계를 유연하게 만들 수 있다.\n구 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작한다.\n가끔은 생성해도 무방하다 # js로 치면 defaultValue 설정과 같은 내용 표준 클래스에 대한 의존은 해롭지 않다. # 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다. 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다. 컨텍스트 확장하기 # DiscountPolicy 추상클래스의 구체클래스로 NoneDiscountPolicy, OverlappedDiscountPolicy 를 구현하여 할인 정책이 없을 때, 중복 적용이 가능할 때 처리가능하도록 할인정책 컨텍스트 확장 조합 가능한 행동 # 다양한 종류의 할인 정책이 필요한 컨텍스트에서 Movie를 재사용할 수 있는 이유는 코드를 직접 수정하지 않고도 협력 대상인 DiscountPolicy 인스턴스를 교체할 수 있기 때문이다. 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다. 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다. 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다. 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다. 이의 핵심은 의존성을 관리하는 것 ","date":"2022 / 07 / 17","permalink":"/posts/study/object/object-08/","section":"Posts","summary":"오브젝트 8장 의존성 관리하기","title":"오브젝트 8장 의존성 관리하기"},{"content":"01. 개방-폐쇄 원칙 # 소프트웨어 개체는 확장에 대해 열려 있어야 학, 수정에 대해서는 닫혀 있어야 한다. 확장에 대해 열려 있다 : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작\u0026rsquo;을 추가하여 기능을 확장한다. 수정에 대해 닫혀 있다 : 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다. 컴파일 의존성을 고정시키고 런타임 의존성을 변경하라 # 사실 개방 폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다. 이전 예제 DIscountPolicy 에서 자식 클래스를 추가함으로써 할인정책이 없거나 중복 적용이 가능한 기능을 확장했다. 단순히 새로운 클래스를 추가하는 것만으로 Movie를 새로운 컨텍스트에 사용되도록 확장할 수 있었음. 개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다. 추상화가 핵심이다 # 개방 폐쇄 원칙의 핵심은 추상화에 의존하는 것이다. 추상화를 사용해 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다. 개방 폐쇄 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다. 추상화를 통해 생략된 부분은 확장의 여지를 남긴다. 이것이 추상화가 개방폐쇄 원칙을 가능하게 만드는 이유이다. 명시적 의존성과 의존성 해결 방법을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다. 핵심은 추상화다. 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다. 변경에 의한 파급효과를 최대한 피하기 위해 변하는 것과 변하지 않는 것이 무엇인지 이해하고 이를 추상화의 목적으로 삼아야만 한다. 추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다. 02. 생성 사용 분리 # 유연하고 재사용 가능한 설계를 위해 객체 생성과, 객체 사용을 분리해야 한다. (생성과 사용 분리) 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다. FACTORY 추가하기 # 생성 책임을 클라이언트로 옮긴 배경에는 Movie는 특정 컨텍스트에 묶여서는 안 되지만, 클라이언트는 묶여도 상관이 없다는 전제가 깔려 있다. 하지만 클라이언트도 특정한 컨텍스트에 묶이길 원하지 않는다면? 이 경우 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 클라이언트에서 사용하도록 만들 수 있다. 이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다. 순수한 가공물에게 책임 할당하기 # FACTORY는 도메인 모델이 아닌, 순수하게 기술적 결정으로 생성된 클래스이다. 전체적으로 결합도를 낮추고 재사용성을 높이기 위해서 도메인 개념에게 할당되어 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다. 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착하게 될 가능성이 높아진다. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 한다. 이러한 도메인과 무관한 인공적 객체를 PURE FABRICATION이라고 부른다. 이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. 객체지향 애플리케이션은 도메인 개념뿐만 아니라 설계자들이 임의로 창조한 인공적인 추상화를 포함한다. 인공적으로 창조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 차지하는 것이 일반적이다. 설계자로서 우리의 역할은 도메인 추상화를 바탕으로 애플리케이션 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 창조하는 것이다. 먼저 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하고, 도메인 개념이 만족스럽지 않다면 인공적인 객체를 창ㅇ조하자. 객체지향이 실세계를 모방해야 한다는 주장에 현혹될 필요가 없다. 03. 의존성 주입 # 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 부른다. 의존성 주입은 의존성을 해결하기 위해 의존성을 객체 퍼블릭 인터페이스에 명식적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭이다. 의존성 주입은 생성자 주입 / setter 주입 / 메서드 주입으로 나뉜다. 숨겨진 의존성은 나쁘다. # 의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 있고 그중 SERVICE LOCATOR 패턴을 소개한다. SERVICE LOCATOR 의존성을 관리하는 객체 저장소를 따로 두고 여기서 이 저장소에 메시지를 전달하는 방법. 의존성이 숨겨지므로 좋은 방법은 아님. 의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 런타임에서 발견되므로 디버깅이 어렵다. 명시적으로 퍼블릭 인터페이스에 의존성을 드러내자. 04. 의존성 역전 원칙 # 추상화와 의존성 역전 # 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의 해 상위 수준의 클래스가 영향을 받게 될 것이다. (ex. Movie클래스가 AmountDiscount에 직접 의존하는 경우) 추상화로 해결한다. (DiscountPolicy) 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다. 정리 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다. 이를 의존성 역전 원칙이라 부른다. 역전이란? 전통적인 절차형 프로그래밍과 의존성 방향이 반대 방향으로 나타나기 때문 05. 유연성에 대한 조언 # 항상 유연한 설게가 좋은것은 아니다. 설계의 미덕은 단순함과 명확함으로 나온다. 단순하고 명확한 설계의 코드는 읽기 쉽고 이해하기 편하다. 하지만 유연한 설계는 이와는 다른 길을 걷는다. 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다. 유연한 설계라는 말의 이면에 복잡한 설계라는 의미가 숨어 있다. 유연한 설계의 이런 양면성은 객관적으로 설계를 판단하기 어렵게 만든다. 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 유연함은 단순성과 명확성의 희생 위에서 자라난다. 유연한 설계를 단순하고 명확하게 만드는 유일한 방법은 사람들 간의 긴밀한 커뮤니케이션뿐이다. 복잡성이 필요한 이유와 합리적인 근거를 제시하지 않는다면 어느 누구도 설계를 만족스러운 해법으로 받아들이지 않을 것이다. 불필요한 유연성은 불필요한 복잡성을 낳는다. 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다. ","date":"2022 / 07 / 17","permalink":"/posts/study/object/object-09/","section":"Posts","summary":"오브젝트 9장 유연한 설계","title":"오브젝트 9장 유연한 설계"},{"content":"7장 객체 분해 # 서론 # 사람의 기억은 단기 기억과 장기 기억으로 분류된다. 장기기억은 경험한 내용을 수개월에서 길게는 영구적으로 보관하는 저장소이다. 일반적으로 장기기억 안에 보관되어 있는 지식은 직접 접근하는 것이 불가능하고 먼저 단기 기억 영역으로 옮긴 후 처리해야 한다. 반면, 단기 기억은 보관되어 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 조지 밀러의 매직넘버7의 규칙에 따르면 동시에 단기 기억안에 저장할 수 있는 정보는 5~9개 뿐이다. 핵심은 실제로 문제를 해결하기 위해 사용되는 저장소는 장기 기억이 아니라 단기기억이라는 점이다. 문제를 해결하기 위해서는 필요한 정보들을 먼저 단기기억으로 불러들여야 한다. 그러나 문제 해결에 필요한 요소의 수가 단기기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어지고 만다. 이런 현상을 인지 과부하라고 한다. 인지 과부하를 방지하는 좋은 방법은 단기기억 안에 보관할 정보의 양을 조절하는 것이다. 한 번에 다룰 정보의 양을 줄인다. 이처럼 불필요한 정보를 제거하고 문제 해결에 필요한 핵심만을 남기는 작업을 추상화라고 한다. 가장 일반적인 추상화 방법은 한 번에 다뤄야 할 문제의 크기를 줄이는 것이다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해 라고 부른다. 분해의 목적은 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것이다. 한 번에 단기 기억에 담을 수 있는 추상화 수에는 한계가 있지만 추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수 있다. 따라서 추상화와 분해는 인간이 세계를 인식하고 반응하기 위해 사용하는 기본적인 사고 도구이다. 복잡성이 존재하는 곳에 추상화와 분해 역시 존재한다. 01 프로시저 추상화와 데이터 추상화 # 프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발했다. 언어를 통해 표현되는 추상화의 발전은 다양한 프로그래밍 패러다임으로 이어진다. 프로그래밍 패러다임이란 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합이다. 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정된다. 따라서 모든 프로그래밍 패러다임은 추상화와 분해 관점에서 설명할 수 있다. 현대 프로그래밍 언어를 특징 짓는 중요한 추상화 매커니즘 두 가지 프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화한다. 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다. 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 조작한다. 시스템 분해 방법을 결정하려면 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지를 결정해야 한다. 프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 기능 분해(알고리즘 분해)의 길로 들어서는 것이다. 데이터 추상화를 중심으로 시스템을 분해한다면 두 가지 방법 중 선택해야 한다. 데이터를 중심으로 타입 추상화 - 추상 데이터 타입 데이터를 중심으로 프로시저를 추상화 - 객체지향 지금까지 객체지향 패러다임을 역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것으로 설명했다. 여기서 ‘역할과 책임을 수행하는 자율적인 객체’가 객체지향 패러다임이 이용하는 추상화이다. ‘협력하는 공동체\u0026rsquo;를 구성하도록 객체를 나누는 과정이 바로 객체지향 패러다임의 분해에 해당한다. 언어 관점에서 객체지향을 바라보면, 기능을 구현하기 위해 필요한 객체를 식별하고 협력 가능하도록 시스템을 분해한 후에는 프로그래밍 언어라는 수단을 이용해 실행 가능한 프로그램을 구현해야 한다. 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법이다. 이런 객체를 구현하기 위해 대부분 클래스를 사용한다. 따라서 프로그래밍 언어 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것. 02. 프로시저 추상화와 기능 분해 # 메인 함수로서의 시스템 # 기능은 과거 오랜시간 동안 시스템을 분해하기 위한 기준으로 사용 되었음. 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다. 프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 사용할 수 있기 때문이다. 프로시저는 잠재적으로 정보은닉의 가능성을 제시하지만 뒤에서 살펴보는 것처럼 프로시저만으로 효과적인 정보은닉 체계를 구축하는 데는 한계가 있다. 전통적인 기능 분해 방법은 하향식 접근법을 따른다. 하향식 접근법이란 시스템을 구서앟는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다. 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다. 각 세분화 단계는 바로 위 단계보다 더 구체적이어야 한다. 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다. 급여 관리 시스템 예시 # 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다.\n기능분해라는 무대의 주연은 기능이며 데이터는 기능을 보조하는 조연의 역할에 머무른다. 이는 유지보수에 다양한 문제점을 야기한다. 하향식 기능 분해 방식이 가지는 문제점을 이해하는 것이 객체지향의 장점을 이해할 수 있는 좋은 출발점. 하향식 기능 분해는 시스템을 최상위의 가장 추상적인 메인 함수로 정의하고, 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해하는 방법이다.\n하향식 기능 분해는 논리적이고 체계적인 시스템 개발 절차를 제시한다. 커다란 기능을 좀 더 작은 기능으로 단계적으로 정제해 가는 과정은 구조적이며 체계적인 동시에 이상적인 방법으로까지 보일 것이다. 문제는 우리가 사는 세계는 그렇게 체계적이지도, 이상적이지도 않다는 점이다. 체계적이고 이상적인 방법이 불규칙하고 불완전한 인간과 만나는 지점에서 혼란과 동요가 발생한다. 하향식 기능 분해의 문제점 # 문제점 시스템은 하나의 메인 함수로 구성돼 있지 않다. 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다. 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다. 하향신 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다. 데이터 형식이 변경될 경우 파급효과를 에측할 수 없다. 설계는 코드 배치 방법이며 설계가 필요한 이유는 변경에 대비하기 위한 것이라는 점을 기억하라. 변경은 성공적인 소프트웨어가 맞이해야 하는 피할 수 없는 운명이다. 현재의 요구사항이 변하지 않고 코드를 변경할 필요가 없다면 소프트웨어를 어떻게 설계하던 아무도 신경쓰지 않을 것이다. 하지만 설계는 변경된다. 하나의 메인 함수라는 비현실적인 아이디어 # 어떤 시스템도 최초에 릴리즈됐던 당시의 모습을 그대로 유지하지는 않는다. 시간이 지나고 사용자를 만족시키기 위한 새로운 요구사항을 도출해나가면서 지속적으로 새로운 기능을 추가하게 된다. 이것은 시스템이 오직 하나의 메인 함수만으로 구현된다는 개념과는 완전히 모순된다. 대부분의 경우 추가되는 기능은 최초에 배포된 메인 함수의 일부가 아닐 것이다. 결국 처음에는 중요하게 생각됐던 메인 함수는 동등하게 중요한 여러 함수들 중 하나로 전락하고 만다. 어느 시점에 이르면 유일한 메인함수라는 개념은 의미 없어지고 시스템은 여러 개의 동등한 수준의 함수 집합으로 성장하게 될 것이다. 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다. 모든 기능들은 규모라는 측면에서 차이가 있을 수는 있겠지만 기능성의 측면에서는 동등하게 독립적이고 완결된 하나의 기능을 표현한다. 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다. 메인 함수의 빈번한 재설계 # 시스템 안에는 여러 개의 정상이 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다. 기존 로직과는 아무런 상관없는 새로운 함수의 적절한 위치를 확보해야 하기 때문에 메인 함수의 구조를 급격하게 변경할 수 밖에 없다. 기존 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다. 비즈니스 로직과 사용자 인터페이스의 결합 # 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. 결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다. 문제는 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다. 당연히 사용자 인터페이스는 자주 변경되고, 반면 비즈니스 로직은 비교적 변경이 적게 발생한다. 하향식 접근법은 사용자 인터페이스 로직과 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경하는 경우 비즈니스 로직까지 변경에 영향을 받게 된다. 따라서 하향식 접근법은 근본적으로 변경에 불안정한 아키텍처를 낳는다. 하향식 접근법은 기능을 분해하는 과정에서 사용자 인터페이스의 관심사와 비즈니스 로직의 관심사를 동시에 고려하도록 강요하기 때문에 ‘관심사의 분리\u0026rsquo;라는 아키텍처 설게의 목적을 달성하기 어렵다. 성급하게 결정된 실행 순서 # 하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다. 이는 설계를 시작하는 시점부터 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만든다. 하향식 접근법은 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행순서를 정의하는 시간제약을 강조한다. 메인 함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야 한다. 실행 순서나 조건, 반복과 같은 제어구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문에 기능 분해 방식은 중앙집중 제어 스타일의 형태를 띨 수 밖에 없다. 결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다. 문제는 함수의 제어 구조가 빈번한 변경의 대상이라는 점이다. 기능을 추가하거나 변경하느 작업은 기존에 결정된 함수의 제어구를 변경하게 만든다. 이를 해결하기 위한 한 가지 방법은 자주 변경되는 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 논리적인 제약을 설계의 기준으로 삼는 것이다. 객체지향은 함수 간의 호출 순서가 아니라 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어 나간다. 결과적으로 전체적인 시스템은 어떤 한 구성요소로 제어가 집중되지 않고 여러 객체들 사이로 제어 주체가 분산된다. 하향식 접근법을 통해 분해한 함수들은 재사용하기도 어렵다. 모든 함수는 상위 함수를 분해하는 과정에서 필요에 따라 식별되며, 상위 함수가 강요하는 문맥 안에서만 의미를 가지기 때문이다. 재사용이라는 개념은 일반성이라는 의미를 포함한다. 함수가 재사용 가능하려면 상위 함수보다 더 일반적이어야 한다. 하지만 하향식 접근법을 따를 경우 분해된 하위 함수는 항상 상위 함수보다 문맥에 더 종속적이다. 이는 정확하게 재사용성과 반대되는 개념임. 하향식 설게와 관련된 모든 문제의 원인은 결합도다. 함수는 상위 함수가 강요하는 문맥에 강하게 결합된다. 데이터 변경으로 인한 파급효과 # 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다. 따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다. 이는 의존성과 결합도의 문제다. 데이터의 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼져나간다. 모든 함수를 분석해서 영향도를 파악하고 변경될 전역 변수에 의존하는 함수를 찾는것은 어려운 일. 코드가 성장하고 라인 수가 증가할수록 전역 데이터를 변경하는 것은 악몽으로 변해간다. 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 한다. 즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다. 이것이 의존성 관리의 핵심이다. 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지 않는 부분을 명확하게 분리하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하라. 언제 하향식 분해가 유용한가? # 하향식 아이디어가 매력적인 이유는 설계가 어느 정도 안정화 된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기 용이하기 때문이다. 그러나 설계를 문서화 하는 데 적절한 방법이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아니다. 마이클 잭슨(개발자)의 하향식 방법 설명 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다. 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다. 시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 가지고 있다면 머릿속에 있는 것을 종이에 서술하기 위해 하향식을 사용할 수 있다. 이것이 사람들이 하향식 설계나 개발을 할 수 있고, 그렇게 함으로써 성공할 수 있다고 믿게 만드는 이유다. 하향식 단계가 시작될 때 문제는 이미 해결됐고, 오직 해결돼야 하는 세부사항만이 존재할 뿐이다. 03. 모듈 # 정보 은닉과 모듈 # 시스템 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다. 즉, 기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것이다. 정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다. 시스템을 모듈로 분할하는 원칙은 외부에 유출돼서는 안 되는 비밀의 윤곽을 따라야 한다고 주장한다. 모듈과 기능 분해는 상호 배타적인 관계가 아니다. 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다. 기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다. 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다. 모듈은 다음 두 가지 비밀을 감춰야 한다. 복잡성 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다. 변경 가능성 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다. 비밀이 반드시 데이터일 필요는 없다. 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있음. 모듈의 장점과 한계 # 장점 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다. 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다. 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 만든다. 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다. 따라서 모듈 내부는 높은 응집도를 유지한다. 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신하므로 낮은 결합도를 유지한다. 한계 모듈은 인스턴스 개념을 제공하지 않음. 이 한계를 극복하기 위해 추상 데이터 타입이 나옴. 04. 데이터 추상화와 추상 데이터 타입 # 추상 데이터 타입 # 타입이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.\n타입은 저장된 값에 대해 수해오딜 수 있는 연산의 집합을 결정하기 때문에 변수의 값이 어떻게 행동할 것이라는 것을 예측할 수 있게 한다. 리스코프는 프로시저 추상화를 보완하기 위해 데이터 추상화의 개념을 제안했다.\n추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정한다. 이는 오퍼레이션을 이용해 추상 데이터 타입을 정의할 수 있음을 의미한다. 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부적인 사항에 대해 무시한다. 객체가 저장소 내에서 어떻게 표현되는지와 같은 구현 정보는 오직 오퍼레이션을 어떻게 구현할 것인지에 집중할 때만 필요하다. 비록 추상 데이터 타입 정의를 기반으로 객체를 생성하는 것은 가능하지만 여전히 데이터와 기능을 분리해서 바라본다는 점에 주의하자.\n추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현한다. 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다. 추상 데이터 타입은 데이터에 대한 관점을 설계 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있다. 05. 클래스 # 클래스는 추상 데이터 타입인가? # 명확한 의미에서 추상데이터 타입과 클래스는 동일하지 않다. 클래스는 상속과 다형성을 지원한다. 추상 데이터 타입은 타입을 추상화한 것이고 클래스는 절차를 추상화한 것이다. 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 묶고, 객체지향은 타입을 기준으로 오퍼레이션을 묶는다. 변경을 기준으로 선택하라 # 클래스가 추상 데이터 타입의 개념을 따르는지를 확인하는 간단한 방법은 클래스 내부에 타입을 표현하는 변수가 있는지를 살펴보는 것이다.\n추상 데이터 타입으로 구현된 클래스(예제 코드)를 보면 hourly를 통해 직원의 유형을 유추한다. (hourly가 true면 아르바이트생, false면 정직원) 이처럼 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다. 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.\n클라이언트가 객체 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다. 이처럼 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙이라고 부른다.\n이것이 객체지향 설계가 전통적인 방식에 비해 변경하고 확장하기 쉬운 구조를 설계할 수 있는 이유다. 객체지향과 추상 데이터 타입 중 어느 방식으로 설계해야 하는가?\n설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다. 타입 추가에 대한 변경의 압박이 강하다면 객체지향으로, 오퍼레이션 변경에 대한 압박이 강하다면 추상 데이터 타입이 유용하다. 변경의 축을 찾고 접근하자. ","date":"2022 / 07 / 10","permalink":"/posts/study/object/object-07/","section":"Posts","summary":"오브젝트 7장 객체 분해","title":"오브젝트 7장 객체 분해"},{"content":" 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. 정확히는 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것이다. 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족하다. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 한다. 01. 협력과 메시지 # 클라이언트 - 서버 모델 # 메시지는 객체 사이의 협력을 가능하게 하는 매개체다. 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것이다. 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다. 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다. 협력은 클라이언트가 서버의 서비스를 요청하는 단방향의 상호작용이다. 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다. 하나는 객체가 수신하는 메시지의 집합이고 다른 하나는 외부의 객체에게 전송하는 메시지의 집합이다. 대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는게 바람직하다. 메시지와 메시지 전송 # 메시지 : 객체들이 협력하기 위해 사용할 수 있는 의사소통 수단 메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. condition.isSatisfiedBy(screening) 의 코드에서 condition : 수신자 isSatisfiedBy : 오퍼레이션명 screening : dlswk 메시지와 메서드 # 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다. 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다. 중요한 것은 코드상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.(다형성) 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다. 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다. 퍼블릭 인터페이스와 오퍼레이션 # 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다. 외부에선 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다. 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다. 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다. 시그니처 # 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다. 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것으로 정의할 수 있다. 중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오프레이션을 결정한다는 것이다. 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있음. 02. 인터페이스와 설계 품질 # 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다. 최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다. 책임 주도 설계 방법은 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다. 따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다. 또한 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 한다. 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다. 책임 주도 설계가 훌륭한 인터페이스를 얻을 지침을 제공한다고 하더라도 훌륭한 인터페이스가 가지는 공통적인 특징을 아는 것은 여러분의 안목을 넓히고 올바른 설계에 도달할 수 있는 지름길을 제공한다. 디미터 법칙 # 협력하는 객체 내부 구조에 대한 결합으로 인한 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다. 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라. “낮선 자에게 말하지 말라” “오직 인접한 이웃하고만 말하라” 자바와 같은 .(도트)를 이용해 메시지 전송을 표현하는 언어에서는 “오직 하나의 도트만 사용하라\u0026quot;라는 말로 요약되기도 한다. 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야 한다. thi 객체 메서드의 매개변수 this의 속성 this의 속성인 컬렉션 요소 메서드 내에서 생성된 지역 객체 디미터 법칙을 따르면 부끄럼타는 코드(shy code)를 작성할 수 있다. 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다. 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다. screening.getMovie().getDiscountConditions(); 위 코드는 디미터 법칙을 위반하는 코드의 전형적인 모습이다. 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송한다. 이와 같은 코드를 기차 충돌이라 부른다. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다. 따라서 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 수신자의 내부 구현에 강하게 결합된다. screeening.calculateFee(audienceCount); 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청하자. 묻지말고 시켜라 # 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다. ‘묻지말고 시켜라\u0026rsquo;는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다. 메시지 전송자는 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다. 해당 로직은 메시지 수신자가 담당해야 할 책임일 것이다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다. 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다 묻지말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다. 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다. 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다. 묻지말고 시켜라 원칙에 따르도록 메시지를 결정하다 보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다. 묻지말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다. 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라. 의도를 드러내는 인터페이스 # 켄트백은 메서드를 명명하는 두 가지 방법을 소개함\n첫 번째는 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것이다. class PeriodCondition { isSatisfiedByPeriod(screening: Screening) {} } class SequenceCondition { isSatisfiedBySequence(screening: Screening) {} } 이 경우 메서드의 이름은 내부의 구현방법을 드러낸다. 이런 스타일은 좋지 않은데 그 이유를 두 가지로 요약할 수 있다. 메서드에 대해 제대로 커뮤니케이션 하지 못한다. 클라이언트 관점에서 isSatisfiedbyPeriod와 isSatisfiedBySequence는 모두 할인 조건을 판단하는 동일한 작업을 수행한다. 하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아채기 어렵다. 더 큰 문제는 메서드 수준에서 캡슐화를 위반한다는 것이다. 이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다. PeriodCondition을 사용하는 코드를 SequenceCondition을 사용하도록 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야 한다. 메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이언트 코드도 함게 변경해야 한다는 것을 의미한다. 따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수 밖에 없다. 메서드 이름을 짓는 두 번째 방법은 ‘어떻게\u0026rsquo;가 아니라 ‘무엇\u0026rsquo;을 하는지 드러내는 것이다. 메서드의 구현이 한 가지인 경우에는 무엇을 하는지를 드러내는 이름을 짓는 것이 어려울 수 있다. 하지만 무엇을 하는지를 드러내느 ㄴ이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길이다. class PeriodCondition { isSatisfiedBy(screening: Screening) {} } class SequenceCondition { isSatisfiedBy(screening: Screening) {} } 클라이언트 입장에서 두 메서드는 동일한 메시지를 서로 다른 방법으로 처리하기 때문에 서로 대체 가능하다. 메서드를 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.\n이처럼 이름을 짓는 패턴을 의드로를 드러내는 선택자라고 부른다.\n켄트백은 메서드에 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각할 것을 조언한다.\n하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 훈련방법은 매우 다른 두 번째 구현을 상상하는 것이다. 그리고 해당 메서드에 동일한 이름을 붙인다고 상상해보라. 그렇게 하면 아마도 그 순간에 여러분이 할 수 있는 가장 추상적인 이름을 메서드에 붙일 것이다. 에릭 에반스는 켄트백의 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 의도를 드러내는 인터페이스를 제시함.\n의도를 드러내는 인터페이스를 한 마디로 요약하면 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것이다. 객체에게 묻지말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다. 함께 모으기 # 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다. 일반적으로 프로그램에 노출되는 객체 사이의 관계가 많아질수록 결합도가 높아지기 때문에 프로그램은 불안정해진다. 03. 원칙의 함정 # 위에서 배운 설계원칙은 훌륭하지만 절대적인 원칙은 아니다. 소프트웨어 설계에 법칙이란 존재하지 않는다. 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다. 설계는 트레이드오프의 산물이다. 초보자는 원칙을 맹목적으로 추종하고, 적용하려는 원칙이 서로 충돌하는 경우에 원칙에 정당성을 부여하고 억지로 끼워맞추려고 노력한다. 결과적으로 설계는 일관성을 잃어버리고 코드는 무질서 속에 파묻히며 개발자는 길을 잃은 채 방황하게 된다. 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라. 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다. 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다. # Instream.of(1, 15, 20, 3, 9).filter(x -\u0026gt; x -\u0026gt; 10).distinct().count(); 위 코드는 디미터 법칙을 위반하지 않는다. 디미터 법칙은 결합도돠 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정한다. Instream은 다른 Instream으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다. 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 유출하지 않는다면 그것은 디미터 법칙을 준수한 것이다. 결합도와 응집도의 충돌 # 묻지말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로만 귀결되는 것은 아니다. 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 결과적으로 객체는 상관없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다. 클래스는 하나의 변경 원인만을 가져야 한다. 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다. 따라서 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 응집도가 낮은 객체로 넘쳐날 것이다. PeriodCondition클래스의 isSatisfiedBy 메서드를 screening으로 옮기면? PeriodCondition 클래스에서 screening의 내부상태를 사용하기 때문에 캡슐화를 위반한 것은 맞다. 하지만 할인 여부를 판단하는 로직의 본질적인 책임은 screening이 아닌 periodCondition 객체이다. 04. 명령-쿼리 분리 원칙 # 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.\n어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴이라고 부른다.\n루틴은 다시 프로시저와 함수로 구분할 수 있다. 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환하지 않는다. 함수는 값을 반환할 수 있지만 부수효과를 발생할 수 없다. 명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.\n객체의 상태를 수정하는 오퍼레이션을 명령이라고 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다. 개념적으로 명령은 프로시저와 동일하고 쿼리는 함수와 동일하다. 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.\n어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다. 명령-쿼리 분리 원칙을 한 문장으로 표현하면 “질문이 답변을 수정해서는 안된다”는 것이다.\n명령은 상태를 변경할 수 있지만 상태를 반환해서는 안 된다. 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다. 부수효과를 발생시키지 않는 것만을 함수로 제한함으로써 소프트웨어에서 말하는 ‘함수’의 개념이 일반 수학에서의 개념과 상충되지 않도록 한다.\n객체를 변경하지만 직접적으로 값을 반환하지 않는 명령과 객체에 대한 정보를 반환하지만 변경하지 않는 쿼리간의 명확한 구분을 유지한다. 반복 일정의 명령과 쿼리 분리하기 # 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기 어려워진다. 겉으로 보기에는 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다. 가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것이다. 명령-쿼리 분리와 참조 투명성 # 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적으로나마 누릴 수 있게 된다. 참조 투명성이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다. 컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과의 존재 유무다. 프로그램에서 부수효과를 발생시키는 두 가지 대표적인 문법은 대입문과 ㅎ마수다. 수학의 경우 x의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다. 함수는 내부에 부수효과를 포함할 경우 동인한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다. 참조 투명성이란 “어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성\u0026quot; 이다. f(1)이 항상 3으로 불변성을 가진다면 참조 투명성을 만족시킬 수 있다. 참조 투명성을 만족하는 식은 우리에게 두 가지 장점을 제공한다. 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다. 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다. 객체 지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 명령-쿼리 분리원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다. ","date":"2022 / 07 / 07","permalink":"/posts/study/object/object-06/","section":"Posts","summary":"오브젝트 6장 메시지와 인터페이스","title":"오브젝트 6장 메시지와 인터페이스"},{"content":" 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않다는 것이다. 책임 할당 과정은 일종의 트레이드오프 활동이다. 동일한 문제를 해결할 수 있는 다양한 책임할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다. 01. 책임 주도 설계를 향해 # 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다. 데이터보다 행동을 먼저 결정하라 협력이라는 문맥 안에서 책임을 결정하라 데이터 보다 행동을 먼저 결정하라 # 객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다. 클라이언트 관점에서 객체가 수행하는 행동이란 곧 객체의 책임을 의미한다. 객체는 협력에 참여하기 위해 존재하며 협력 안에서 수행하는 책임이 객체의 존재가치를 증명한다. 데이터는 객체가 책임을 수행하는데 필요한 재료를 제공할 뿐이다. 너무 이른시기에 데이터에 초점을 맞추면 객체의 캡슐화가 약화되기 때문에 낮은 응집도와 높은 결합도를 가진 객체들로 넘쳐나게 된다. 책임 중심의 설계에서는 “이 객체가 수행해야 하는 책임을 무엇인가\u0026quot;를 결정한 후에 “이 책임을 수행하는 데 필요한 데이터는 무엇인가\u0026quot;를 결정한다. 객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정한다. 객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력이다. 협력이라는 문맥 안에서 책임을 결정하라 # 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다. 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다. 협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미한다. 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다. 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야한다. 메시지 기반의 설계 관점은 클래스 기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해준다. “메시지를 전송해야 하는데 누구에게 전송해야 하지?”라고 질문하는 것이 첫걸음 메시지가 클라이언트의 의도를 표현한다는 사실에 주목하라. 클라이언트는 어떤 객체가 메시지를 수신할지 알지 못한다. 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다. 메시지를 수신하기로 결정된 객체는 메시지를 처리할 ‘책임\u0026rsquo;을 할당받게 된다. 메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없다. 전송자의 관점에서 수신자가 캡슐화되는 것이다. 이처럼 처음부터 데이터에 집중하는 데이터 중심의 설계가 캡슈로하에 취약한 반면 협력이라는 문맥 안에서 메시지에 집중하는 책임 중심의 설계는 캡슐화의 원리를 지키기가 훨씬 쉬워진다. 책임 중심의 설계가 응집도가 높고 결합도가 낮으며 변경하기 쉬운 이유 책임 주도 설계 # 3장의 책임 주도 설계 흐름 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. 시스템 책임을 더 작은 책임으로 분할한다. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행하는 객체를 결정하는 것 그리고 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 객체 내부 상태에 관심을 가지지 않는 것이다. 02. 책임 할당을 위한 GRASP 패턴 # GRASP(General Responsibility Assignment Software Pattern - 일반적인 책임 할당을 위한 소프트웨어 패턴) 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것 도메인 개념에서 출발하기 # 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다. 도메인 개념들을 책임 할당 대상으로 사용하면 코드에 도메인의 모습을 투영하기 수월하다. 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다. 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다. 단지 우리에게는 출발점이 필요할 뿐이다. 중요한 것은 설계를 시작하는 것이니 도메인 개념을 완벽하게 정리하는 것이 아니다. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라. 올바른 도메인 모델이란 존재하지 않는다. 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 되어야 한다. 도메인 모델이 구현을 염두에 두고 구조화되는 것이 바람직하며, 반대로 코드의 구조가 도메인을 바라보는 관점을 바꾸기도 한다. 올바른 도메인 모델이란 존재하지 않는다. 필요한 것은 도메인을 그대로 투영한 모델이 아니라 구현에 도움이 되는 모델이다. 정보 전문가에게 책임을 할당하라 # 책임 주도 설계방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다. 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 한다. “메시지를 전송할 객체는 무엇을 원하는가?” 메시지를 결정하면 메시지에 적합한 객체를 선택해야 한다. “메시지를 수신할 적합한 객체는 누구인가?” 객체는 상태와 행동을 통합한 캡슐화의 단위이다. 객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 한다. 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 한다. 따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고있는 객체에게 책임을 할당하는 것이다. GRASP - INFORMATION EXPERT(정보 전문가) 패턴 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라 여기서 정보를 ‘알고\u0026rsquo;있다고 해서 그 정보를 ‘저장\u0026rsquo;하고 있을 필요는 없음. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다. 만약 스스로 처리할 수 없는 작업이 있다면 외부에 도움을 요청해야 한다. 이 요청이 외부로 전송해야 하는 새로운 메시지가 되고, 최종적으로 이 메시지가 새로운 객체의 책임으로 할당된다. 이 같은 연쇄적인 메시지 전송과 수신을 통해 협력 공동체가 구성된다. 높은 응집도와 낮은 결합도 # 설계는 트레이드오프 활동이다. 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재한다. 따라서 실제로 설계를 진행하다 보면 몇 가지 설계 중 한 가지를 선택해야 하는 경우가 빈번하다. 이 경우에 올바른 책임 할당을 위해 INFORMATION EXPERT 패턴 이외의 다른 책임 할당 패턴들을 함께 고려할 필요가 있다. 높은 응집도(HIGH COHESION) 낮은 결합도(LOW COUPLING)은 객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리이다. 창조자에게 객체 생성 책임을 할당하라 # 영화 예매 예시의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다. 이것은 협력에 참여하는 어떤 객체에게는 Reservation 인스턴스를 생성할 책임을 할당해야 한다는 것이다. CREATOR 패턴 객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B가 객체 생성 책임을 할당하라. B가 A객체를 포함하거나 참조한다. B가 A객체를 기록한다. B가 A객체를 긴밀하게 사용한다. B가 A객체를 초기화하는 데 필요한 데이터를 가지고 있다.(정보 전문가) 이미 결합되어 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. CREATOR패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다. 03. 구현을 통한 검증 # DiscountCondition 개선하기 # 변경에 취약한 클래스를 포함하고 있다.\n변경에 취약한 클래스란 코드를 수정해야 하는 이유가 하나 이상 가지는 클래스이다. 응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다.\n낮은 응집도가 초래하는 문제를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 한다. 각기 다른 변경은 코드에 영향을 미치는 시점이 서로 다를 수 있다.\nDiscountCondition은 서로 다른 이유로, 서로 다른 시점에 변경될 확률이 높다. 변경의 이유가 하나 이상인 클래스에는 위험 징후를 또렷하게 드러내는 몇 가지 패턴이 드러난다.\n첫 번째 방법은 인스턴스 변수가 초기화 되는 시점이다. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다. 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은채로 남겨진다. 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다. 두 번째 방법은 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것이다. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 응집도가 낮다. 변경과 유연성 # 설계를 주도하는 것은 변경이다. 변경에 대비할 수 있는 방법은 두가지이다. 하나는 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것. 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다. 대부분의 경우 전자가 좋지만, 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승하더라도 유연성을 추가하는 두 번째 방법이 더 좋다. 04. 책임 주도 설계의 대안 # 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것이다. 아무것도 없는 상태에서 책임과 협력에 관해 고민하기보다는 일단 실행되는 코드를 얻고 난 후에 코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동시키자. 코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안된다. 캡슐화를 향상시키고, 응집도를 높이고, 결합도를 낮춰야 하지만 동작은 그대로 유지해야 한다. 메서드 응집도 # 긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 미친다. 어떤 일을 수행하는지 한 눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다. 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다. 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다. 로직의 일부만 재사용하는 것이 불가능하다. 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다. 긴 메서드는 응집도가 낮기 때문에 이해하기 어렵고 재사용하기도 어려우며 변경하기도 어렵다. 응집도가 낮은 메서드는 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분이다. 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다. 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라. 클래스의 응집도와 마찬가지로 메서드의 응집도를 높이는 이유도 변경과 관련이 깊다. 응집도 높은 메서드는 변경되는 이유가 단 하나여야 한다. 클래스가 작고, 목적이 명확한 메서드들로 구성돼 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지를 쉽게 판단할 수 있다. 메서드의 크기가 작고 목적이 분명하기 때문에 재사용하기도 쉽다. 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기 때문에 코드를 이해하기도 쉽다. 클래스의 길이가 길어지더라도 일반적으로 명확성의 가치가 그보다 중요하다. 코드를 작은 메서드들로 분해하면 전체적인 흐름을 이해하기도 쉬워진다. 동시에 너무 많은 세부사항을 기억하도록 강요하는 코드는 이해하기 어렵다. 큰 메서드를 작은 메서드들로 나누면 한 번에 기억해야 하는 정보를 줄일 수 있다. 세부적인 정보가 필요하다면 그때 각 메서드의 세부 구현을 확인하면 된다. 객체를 자율적으로 만들자 # 어떤 메서드를 어떤 클래스로 이동시켜야 할까? 자신이 소유하고 있는 데이터를 자기 스스로처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다. 따라서 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키자. ","date":"2022 / 07 / 05","permalink":"/posts/study/object/object-05/","section":"Posts","summary":"오브젝트 5장 책임 할당하기","title":"오브젝트 5장 책임 할당하기"},{"content":"01. 데이터 중심의 영화 예매 시스템 # 가끔 나쁜 설계를 살펴보는 과정에서 통찰을 얻기도 한다. 이번 장에서는 데이터(상태) 중심의 관점에서 영화 예매 시스템을 설계해본다. 02. 설계 트레이드오프 # 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화의 응집도, 결합도를 사용한다. 본격적으로 두 방법을 비교하기 전에 세 가지 품질 척도의 의미를 살펴보자. 캡슐화 # 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 구현이란 나중에 변경될 가능성이 높은 어떤 것 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다. 객체를 사용해 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다. 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다. 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다. 객체지향의 가장 중요한 원리가 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다. 캡슐화로 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있다. 응집도와 결합도 # 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.\n모듈내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다. 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가짐. 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.\n어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다. 반면 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다. 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.\n좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.\n하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈 일부만 변경된다면 응집도가 낮은 것이다. 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 위해 코드 구석구석을 헤매고 다니거나 여러 모듈을 동시에 수정할 필요 없이 한 모듈만 수정하면 된다. 결합도는 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.\n결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기 어려워진다. 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.\n인터페이스에 대해 프로그래밍하라 일반적으로 변경될 확률이 매우 적은 안정적인 모듈에는 의존하여 결합도가 높아도 상관없다. (표준 라이브러리 등)\n하지만 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높다. 03. 데이터 중심의 영화 예매 시스템의 문제점 # 데이터 중심의 설계는 캡슐화를 위반하고 객체 내부 구현을 인터페이스의 일부로 만든다. 반면 책임 중심 서례는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다. 캡슐화의 정도가 객체의 응집도와 결합도를 결정한다. 데이터 중심 설계의 대표적인 문제 캡슐화 위반 높은 결합도 낮은 응집도 캡슐화 위반 # class Movie { private Money fee; getFee = () =\u0026gt; this.fee; setFee = () =\u0026gt; this.fee; } 데이터 중심으로 설계한 예시 코드는 오직 메서드를 통해서만 객체의 내부 상태에 접근한다. 위 코드는 직접 내부에 접근할 수 없기 때문에 캡슐화 원칙을 지키는 것 처럼 보이지만, 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다. get, set 메서드는 Movie 내부에 fee라는 이름의 변수가 존재한다는 사실을 퍼블릭 인스턴스에 노골적으로 드러낸다. 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다. 객체가 사용될 문맥을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것이다. 앨런 홀럽은 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라고 부른다. 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다. 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수밖에 없다. 높은 결합도 # 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다. 단지 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다. 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다. 이 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수 밖에 없다. 데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다. 낮은 응집도 # 낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다. 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 다른 모듈에 위치해야할 책임의 일부가 엉뚱한 곳에 위치하게 되기 때문이다. 04. 자율적인 객체를 향해 # 캡슐화를 지켜라 # 캡슐화는 설계의 제 1원리다. 데이터 중심 설계가 낮은 응집도와 결합도로 박살난 원인은 바로 캡슐화를 위반했기 때문 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다. 여기서 말하는 메서드는 단순히 속성 하나의 값을 반환하거나 변경하는 접근자나 수정자를 의미하는 것은 아니다. 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다. class Rectangle { private left: number; private top: number; private right: number; private bottom: number; public getLeft() ... } 위 코드에서 사각형의 너비와 높이를 증가시키는 코드가 필요하다고 가정하자. 이 클래스를 사용하는 클라이언트 측에서 set함수를 이용해 너비와 높이를 변경하는 구현을 직접 해야 한다. 이는 코드 중복을 발생시킬 확률이 높으며 변경에 취약하다. 만약 right와 bottom 대신 length, height를 이용해서 사각형을 표현한다면? 호출부의 모든 코드를 수정해야 한다. class Rectangle { enlarge = (multiple: number) =\u0026gt; { right *= multiple; bottom *= multiple; }; } 위와같이 Rectangle 내부에서 너비와 높이를 조절하는 로직을 캡슐화 하면 두가지 문제를 해결할 수 있다. 스스로 자신의 데이터를 책임지는 객체 # 우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 객체는 단순한 데이터 제공자가 아니다. 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 중요하다. 객체를 설계할 때 ‘이 객체가 어떤 데이터를 포함해야 하는가?’라는 질문은 다음 두 개의 개발적인 질문으로 쪼개져야한다. 이 객체가 어떤 데이터를 포함해야 하는가? 이 객체가 데이터에 대해 수행해야 하는 오퍼레이터는 무엇인가? 05. 하지만 여전히 부족하다 # 06. 데이터 중심 설계의 문제점 # 캡슐화를 위반한 설계는 변경에 취약하다. 데이터 중심의 설계가 변경에 취약한 이유 두 가지 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다. # 데이터 중심 설계를 시작할 때 던지는 첫 번째 질문은 “이 객체가 포함해야 하는 데이터가 무엇인가?” 이다. 데이터는 구현의 일부이다. 데이터 주도 설계는 설계를 시작하는 처음부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 된다. 데이터 중심 설계 방식에 익숙한 개발자들은 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다. 이것은 상태와 행동을 하나의 단위로 캡슐화하는 객체지향 패러다임에 반한다. 이로 인해 접근자와 수정자를 과도하게 추가하게 되고 이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현하게 된다. 접근자와 수정자는 public 속성과 큰 차이가 없기 때문에 객체의 캡슐화는 완전히 무너질 수 밖에 없다. 비록 데이터를 처리하는 작업과 데이터를 같은 객체 안에 두더라도 데이터에 초점이 맞춰져 있다면 만족스러운 캡슐화를 얻기 어렵다. 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. 결과적으로 객체의 인터페이스는 구현을 캡슐화하는데 실패하고 변경은 취약해진다. 결론적으로 데이터 중심 설계는 너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다. 객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경에 취약한 코드를 낳게 된다. 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다 # 올바른 객체지향 설계의 무게 중심은 하상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다. 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 실행 문맥에 대한 깊이있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다. 객체의 인터페이스에 구현이 노출돼 있었기 때문에 협력이 구현 세부사항에 종속돼 있고 그에 따라 객체의 내부 구현이 변경됐을 때 협력하는 객체 모두가 영향을 받는다. ","date":"2022 / 07 / 02","permalink":"/posts/study/object/object-04/","section":"Posts","summary":"오브젝트 4장 설계품질과 트레이드오프","title":"오브젝트 4장 설계품질과 트레이드오프"},{"content":" 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 객체지향에서 가장 중요한 것은 역할, 책임, 협력이다. 01. 협력 # 협력 : 객체들이 앱의 기능을 구현하기 위해 수행하는 상호작용 책임 : 객체가 협력에 참여하기 위해 수행하는 로직 역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 수행하는 것 협력 # 객체지향 시스템은 자율적인 객체들의 공동체이다. 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적 존재이다. 협력은 기능을 구현할 수 있는 유일한 방법이다. 메시지 전송으로부터 협력이 시작된다. 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다. 객체가 메시지를 처리할 방법은 스스로 선택한다는 점이 중요 → 자율성 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기 쉬워진다. 협력이 설계를 위한 문맥을 결정한다. # 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다. 객체의 행동을 결정하는 것이 협력이라면, 객체의 상태를 결정하는 것은 행동이다. 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다. 상태는 객체가 행동하는데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥을 제공한다. 02. 책임 # 책임이란 무엇인가 # 협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다. 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다. 객체의 책임은 무엇을 알고 있는가?(하는 것)와, 무엇을 할 수 있는가? (아는 것) 로 구성된다. 하는 것 객체를 생성하거나 계산을 수행하는 등 스스로 하는 것 다른 객체의 행동을 시작시키는 것 다른 객체의 활동을 제어하고 조절하는 것 아는 것 사적인 정보에 관해 아는 것 관련된 객체에 관해 아는 것 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 협력안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다. 책임과 메시지의 크기는 다르다. 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 더 크다. 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것이다. 적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야만 단순하고 유연한 설계를 창조할 수 있다. 객체에게 얼마나 적절한 책임을 할당하느냐가 설게의 전체적인 품질을 결정한다. 책임 할당 # 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다. 객체들 역시 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다. 요청에 응답하기 위해 필요한 행동이 객체가 수행할 책임으로 이어진다. 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의한다. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다. 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다. 이렇게 결정된 메시지는 객체의 퍼블릭 인터페이스를 구성한다. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션 목록을 얻게 된다. 책임 주도 설계 # 협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다. 어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정한다. 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임주도 설계라고 부른다. 설계 과정 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. 시스템 책임을 더 작은 책임으로 분할한다. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 메시지가 객체를 결정한다. # 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택했다는 것이 중요하다. 메시지가 객체를 선택하게 해야 하는 이유 최소한의 인터페이스를 가질 수 있게 된다. 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 앱에 크지도, 작지도 않은 꼭 필요한 크기의 인터페이스를 가질 수 있다. 충분히 추상적인 인터페이스를 가질 수 있게 된다. 객체의 인터페이스는 무엇을 하는지는 표현해야 하지만 어떻게 수행하는지는 노출해선 안된다. 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 촞머을 맞추는 인터페이스를 얻을 수 있다. 행동이 상태를 결정한다. # 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다. 객체는 협력에 필요한 행동을 제공해야 한다. 객체를 객체답게 만드는 것은 상태가 아니라 행동이다. 객체지향을 갓 입문한 사람이 가장 쉽게 빠지는 실수가 객체의 행동이 아니라 상태에 초점을 맞추는 것이다. 필요한 상태가 무엇인지 먼저 결정하면 객체의 내부 구현이 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다. 03. 역할 # 역할과 협력 # 객체는 협력이라는 문맥 안에서 특정한 목적을 갖게 된다. 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다. 책임의 집합 ⇒ 역할 유연학 재사용 가능한 협력 # 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. 메시지를 수신할 수 있는 객체가 여러개라면, 그들의 대표자를 역할이라는 개념으로 추상화할 수 있음. 2장 예제의 AmountDiscountPolicy, PercentDiscountPolicy 각각의 객체를 추상클래스인 DiscountPolicy로 포괄해서 생각할 수 있음. 역할을 이용하면 불필요한 중복 코드를 제거할 수 있으며, 협력이 더 유연해진다. 어떤 객체라도 동일한 역할을 수행한다면 협력에 참여할 수 있게 된다. 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다. 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 이용하는 것임. 객체 대 역할 # 역할은 객체가 참여할 수 있는 일종의 슬롯이다. 따라서 유용하고 재사용 가능한 설계라는 문맥에서 역할은 중요함. 만약 한 종류의 객체만이 협력에 참여한다면? 굳이 역할로 추상화 하지 않고 객체로 바라봐도 된다. 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고, 역할과 객체를 명확하게 구분짓는 것은 그렇게 중요하진 않다. 구분하기 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법이다. 역할과 추상화 # 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다. 역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 것이다. 추상화의 장점 세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다. 협력이라는 관점에서 세부적인 사항을 무시하고 추상화에 집중하는 것이 유용하다. 설계를 유연하게 만든다. 협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에 서로 대체 가능하다. 따라서 역할은 다양한 환경에서 다양한 객체들을 수용하게 해주므로 협력을 유연하게 만든다. ","date":"2022 / 06 / 30","permalink":"/posts/study/object/object-03/","section":"Posts","summary":"오브젝트 3장 역할, 책임, 협력","title":"오브젝트 3장 역할, 책임, 협력"},{"content":"01. 영화 예매 시스템 # 영화 / 상영 할인 할인 조건 - 할인이 가능한지 할인 정책 - 적용되는 비용 02. 객체지향 프로그래밍을 향해 # 협력, 객체, 클래스 # 대부분의 사람은 클래스를 결정한 후 클래스에 어떤 속성과 메서드가 필요한지 고민한다. 이는 객체지향의 본질과는 거리가 멀다. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다. 객체를 중심에 두는 접근방법은 설계를 단순하고 깔끔하게 만든다. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라 객체는 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다. 객체를 협력 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다. 객체 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라 도메인의 구조를 따르는 프로그램 구조 # 도메인 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다. 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 객체와 클래스로 매끄럽게 연결될 수 있다. 클래스 구현하기 # https://github.com/soso01/object/tree/main/chapter2\n클래스를 구현하거나 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것 구분해야 하는 이유는? 경계의 명확성이 객체의 자율성을 보장한다. 프로그래머에게 구현의 자유를 제공한다. 자율적인 객체 # 중요한 두가지 사실 객체는 상태와 행동을 함께 가지는 복합적인 존재임 객체는 스스로 판단하고 행동하는 자율적인 존재 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다. 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다. 객체지향 언어들은 캡슐화에서 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어 메커니즘도 함께 제공한다. private, protected, public … - 접근 수정자 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서이다. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다. 외부에서는 객체에게 원하는 것을 요청하고 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 한다. 캡슐화와 접근 제어는 두 부분으로 나뉜다. 퍼블릭 인터페이스 - 외부에서 접근 가능한 부분 구현 - 내부에서만 접근가능한 부분 인터페이스와 구현의 분리는 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다. 프로그래머의 자유 # 프로그래머의 역할을 클래스 작성자와, 클라이언트 프로그래머로 구분하자. 클래스 작성자는 새로운 타입을 프로그램에 추가한다. 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다. 접근제어를 통해 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 이를 구현은닉이라고 부른다. 구현은닉은 클라이언트 프로그래머에게도 유용하다. 클라이언트 프로그래머는 내부의 구현을 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다. 설계가 필요한 이유는 변경을 관리하기 위해서다. 객체의 변경을 관리할 수 있는 가장 대표적인 것이 접근 제어다. 변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다. 협력하는 객체들의 공동체 # 가격에 대한 타입을 number 대신 Money라는 새 객체로 정의하는 것은 유용하다. number타입은 Money타입처럼 저장하는 값이 금액과 관련되어 있다는 의미를 전달할 수 없다. 또한 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없다. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있는 것이다. 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라. 협력에 대한 짧은 이야기 # 객체는 외부에 공개되어있는 퍼블릭 인터페이스를 통해 내부 상태에 접근하도록 허용한다. 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있고, 요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것이다. 다른 객체에 요청이 도착할 때 해당 객체가 메시지를 수신한다. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라 부른다. 메시지와 메서드를 구분하는 것은 매우 중요하다. 이 구분은 객체지향 패러다임이 유연하고 확장가능하며, 재사용 가능한 설계를 할 수 있도록 크게 기여함. 메시지와 메서드의 구분에서부터 다형성의 개념이 출발한다. 03. 할인 요금 구하기 # https://github.com/soso01/object/tree/main/chapter2\n04. 상속과 다형성 # 컴파일 시간 의존성과 실행 시간 의존성 # 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 다시 말해, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다. 쉽게 재사용할 수 있으며, 확 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다. 예제에서 코드상 Movie는 DiscountPolicy라는 추상클래스에 의존성을 갖지만, 실행 시점에서의 의존성의 DiscountPolicy의 상속클래스인 AmountDiscountPolicy에 의존한다. 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물임을 보여준다. 설계를가 유연해지면 코드를 이해하고 디버깅하기 점점 더 어려워지고, 유연성을 억제하면 코드를 이해하기 쉽지만, 재사용성과 확장 가능성은 낮아진다. 차이에 의한 프로그래밍 # 상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다. 부모 클래스의 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라고 부른다. 상속과 인터페이스 # 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 자식클래스는 부모 클래스의 인터페이스를 포함하므로, 결과적으로 부모클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다. 외부 클래스의 입장에선 객체가 어떤 클래스의 인스턴스인지 중요하지 않다. 메시지를 수신할 수 있으면 무엇이든 상관없음. 다형성 # 다형성 - 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다. 상속을 이용하면 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다. 05. 추상화와 유연성 # 추상화의 힘 # 추상화를 사용할 경우의 두 가지 장점 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다. 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 한다. 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 설계가 좀 더 유연해진다. 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다. 유연한 설계 # export class Movie { ... calculateMovieFee = (screening: Screening) =\u0026gt; { if (this.discountPolicy === null) return this.fee; return this.fee.minus( this.discountPolicy.calculateDiscountAmount(screening) ); }; } 위 방식의 문제점은 할인 정책이 없는 경우를 예외 케이스로 취급하기 때문에 지금까지 일관성 있었던 협력방식이 무너진다. 할인 금액을 결정하는 책임이 DiscountPolicy가 아닌, Movie쪽에 있다. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다. 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라. export class NoneDiscountPolicy extends DiscountPolicy { protected override getDiscountAmount = () =\u0026gt; Money.ZERO; } 위와 같이 새 클래스를 추가해서 일관성을 지킬 수 있다. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결함되는 것을 방지하기 때문이다. 코드 재사용 # 코드 재사용을 위해서는 상속보다 합성이 더 좋은 방법이다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다. 상속 # 두가지 관점에서 상속은 설계에 좋지 않다. 캡슐화를 위반함 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 결과적으로 부모의 구현이 자식에 노출되기 때문에 캡슐화가 약해진다. 캡슐화의 약화는 자식과 부모를 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식도 함게 변경될 확률을 높인다. 설계를 유연하지 못하게 만듦 상속은 부모와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 바꾸는 것이 불가능하다. 합성 # 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이 합성이다. 합성은 상속이 가지는 두가지 문제를 모두 해결한다. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 그렇다고 상속을 쓰면 안되는 것은 아님. 대부분의 설계에서 상속과 합성을 같이 사용한다. ","date":"2022 / 06 / 26","permalink":"/posts/study/object/object-02/","section":"Posts","summary":"오브젝트 2장 객체지향 프로그래밍","title":"오브젝트 2장 객체지향 프로그래밍"},{"content":"서론 # 실무가 이론보다 먼저다. 실무를 하면서 관찰한 결과를 바탕으로 이론이 정립된다. 소프트웨어 분야는 아직 걸음마 단계에 머물러 있기 때문에 이론보다 실무가 더 앞서있음. 소프트웨어 유지보수의 경우 그 격차가 더 심하다. 실무에서는 다양한 규모의 소프트웨어를 유지보수하고 있지만, 소프트웨어 유지보수에 관련된 효과적인 이론은 발표되지 않았다. 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다. 추상적인 개념과 이론은 훌륭한 코드를 작성하는데 필요한 도구일 뿐이다. 01. 티켓 판매 애플리케이션 구현 # https://github.com/soso01/object/tree/main/chapter1/1-1\n02. 무엇이 문제인가? # 로버트 마틴의 소프트웨어 모듈이 가져야 하는 세 가지 기능 실행 중에 제대로 동작하는 것 변경이 용이 할 것 이해하기 쉬울 것 1-1 챕터의 코드는 제대로 동작하지만, 변경 용이성과 읽는 사람과의 의사소통이라는 목적을 만족시키지 못함. 예상을 빗나가는 코드 # 관람객과 판매원이 극장의 통제를 받는 수동적인 존재이다. 티켓을 꺼내 관람객의 가방에 집어넣고, 관람객에게 받은 돈을 매표소에 적립하는 행동을 극장이 수행한다. 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. 위의 예시는 일반 상식과 다르게 동작하기 때문에 코드를 읽는 사람과 제대로 소통하지 못함. 극장에 모든 세부적인 내용이 한번에 들어가기 때문에 판매원, 관람객의 세부사항을 극장에서 알고 있어야 한다. 변경에 취약한 코드 # 의존성은 변경에 대한 영향을 암시한다. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포됨 객체 사이의 의존성이 과한 경우 결합도가 높다고 말한다. 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다. 03. 설계 개선하기 # https://github.com/soso01/object/tree/main/chapter1/1-3\n코드를 이해하기 어려운 이유는 극장에서 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다. 의도를 정확하게 의사소통하지 못하기 때문에 코드가 이해하기 어려워진 것이다. 극장이 관람객과 판매원의 너무 세세한 부분까지 알지 못하도록 정보를 차단하자. 관람객과 판매원을 자율적인 존재로 만든다. 자율성을 높이자 # 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라 한다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다. 수정 사항 # 수정된 관람객과 판매원은 자신이 가지고 있는 소지품을 스스로 관리한다. 이는 우리의 예상과 일치하게 작동하는 코드다. 읽는 사람과의 의사소통이라는 관점에서 확실히 개선되었다. 관람객과 판매원의 내부 구현을 변경하더라도 극장의 코드를 함께 변경할 필요가 없어졌다. 객체의 자율성을 높이는 방향으로 설계를 개선하여, 이해하기 쉽고 유연한 설계를 얻을 수 있었다. 캡슐화와 응집도 # 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메세지를 통해서만 상호작용하도록 만드는 것이다. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다. 자신의데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다. 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다. 자신이 소유하고 있지 않은 데이터를 이용해 작업을 처리하는 객체에게 어떻게 연관성 높은 작업들을 할당할 수 있겠는가? 외부의 간섭을 최대한 배제하고 메세지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다. 절차지향과 객체지향 # 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.\n절차적 프로그래밍의 세상은 우리의 예상을 쉽게 벗어나기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.\n절차적 프로그래밍의 세계에서 관람객과 판매원은 수동적인 존재 절차적 프로그래밍의 세상에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.\n따라서 변경하기 어려운 코드를 양산하는 경향이 있다. 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.\n절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수 밖에 없다. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 프로그래밍 방식을 객체지향 프로그래밍이라고 부른다.\n자신의 데이터를 스스로 처리하도록 극장의 프로세스를 판매원과 관람객으로 이동 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.\n책임의 이동 # 두 방식 사이에 근본적인 차이를 만드는 것은 책임의 이동이다. 여기서 책임은 기능을 가리키는 객체지향 세계의 용어로 생각해도 무방함. 절차지향 방식에서는 책임이 극장에 집중되어 있었음. 그에 반해 객체지향 설계에서는 제어 흐름이 각 객체에 적절하게 분산된다. 극장에 몰려있던 책임이 각 개별 객체로 이동한 것. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다. 객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다. 사실 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다. 객체가 어떤 데이터를 가지느냐 보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞추자 설계를 어렵게 만드는 것은 의존성이다. 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추자. 더 개선하기 # 관람객이 소지하고 있는 가방과, 판매원의 판매소 객체에 자율권을 가지도록 수정함. 자율권을 주기 위해 기존에 없었던 의존성이 생겨날 수 있다. 결합도와 자율성 모두를 만족시키는 방법이 없다면 트레이드 오프를 해야 한다. 이 예제로 알 수 있는 것 두가지 어떤 기능을 설계하는 방법은 한 가지 이상이다. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다. 그래, 거짓말이다 # 직관에 따르는 코드는 이해하기 더 쉽다. 하지만 이후에 수정한 가방과 판매소는 실세계에서 자율적인 존재가 아니므로 어색하게 느껴진다. 코드에서 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급한 것이다. 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다. - 의인화 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 그 대상이 비록 생명이 없는 수동적인 존재라고 생각하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다. 04. 객체지향 설계 # 설계가 왜 필요한가 # 설계란 코드를 배치하는 것이다. 어떤 사람들은 설계가 코드를 작성하는 것보다 높은 차원의 창조적인 행위라고 생각한다. 하지만 설계와 구현을 떨어뜨려서 이야기하는 것은 불가능하다. 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다. 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다. 좋은 설계란 무엇인가? 우리는 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 변경을 수용할 수 있는 설계가 중요한 또 다른 이유는 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다. 요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그가 발생할 가능성을 높인다. 버그의 가장 큰 문제점은 코드를 수정하려는 의지를 꺾는다. 객체지향 설계 # 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다. 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다. 변경 가능한 코드란 이해하기 쉬운 코드다. 객체지향 패러다임은 여러분이 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다. 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니다. 객체지향의 세계에서 애플리케이션은 객체들로 구성되며 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현된다. 객체들 사이의 상호작용은 객체 사이에 주고 받는 메시지로 표현된다. 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다. 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다. 데이터와 프로세스를 하나의 덩어리로 모드는 것은 훌륭한 객체지향 설계로 가는 첫걸음일 뿐이다. 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다. ","date":"2022 / 06 / 25","permalink":"/posts/study/object/object-01/","section":"Posts","summary":"오브젝트 1장 객체, 설계 요약","title":"오브젝트 1장 객체, 설계 요약"},{"content":" nestjs 공부 목적으로 간단한 로그인 페이지를 만들었다.\nnestjs에 orm은 prisma로 postgres 썼고, 인증쪽은 passport-jwt 라이브러러리 사용했다.\n느낀점은 개념을 알고나니 생각보다 생산성이 좋다. express보다 코드량이 늘어나서 개발속도가 느려지지 않을까 생각했었다. 하지만 nest의 필터, 가드 등의 개념들은 어차피 express에서도 구현했어야 하는 부분들이고, 오히려 nest cli 로 리소스 생성하는게 편해서 express보다 만족도가 높았다. 구조가 정해져 있으니 고민할게 적은 점도 장점이다.\n프론트랑 백엔드 앱 두개를 같이 개발했는데 테스트를 짜는게 힘들다. 정확히는 백엔드에서 테스트코드를 작성하면서 api를 만들고 나서, 프론트 개발을 할때 어차피 서버에서 검증한 데이터라고 생각되어서 테스트를 짜는게 귀찮아진다. 그래서 위 레포에서는 프론트 테스트는 하나도 없다. 서버의 테스트와 중복되지 않는 의미있는 테스트만 작성하려면 어떻게 해야 할까\n링크 - https://github.com/soso01/nestjs-study\n","date":"2022 / 06 / 01","permalink":"/posts/dev/nest-auth/","section":"Posts","summary":"nestjs 회원가입, 인증","title":"nestjs 회원가입, 인증"},{"content":"클래스 체계 # 자바 표준 관례에 따른 순서 정적 공개 상수 \u0026gt; 정적 비공개 변수 \u0026gt; 비공개 인스턴스 변수 \u0026gt; 공개함수.. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다. 캡슐화 # 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다. 테스트를 위해 protected로 선언하는 경우도 있지만 캡슐화를 풀어주는 결정은 언제나 최후의 수단이어야 한다. 클래스는 작아야 한다! # 함수는 물리적인 행 수로 크기를 측정했지만, 클래스는 다르다. 클래스는 맡은 책임을 센다. 메서드 갯수가 작더라도 책임이 너무 많다면 좋지않다. 클래스 이름이 모호하다면 클래스의 책임이 너무 많아서다. 단일 책임 원칙 # 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다. 클래스는 책임, 즉 변경할 이유가 하나여야 한다는 의미다. 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. SRP는 클래스 설계자가 가장 무시하는 규칙 중 하나다. 소프트웨어를 돌아가게 만드는 활동과 깨끗하게 만드는 활동은 별개다. 우리들 대다수는 두뇌 용량에 한계가 있어 ‘깨끗하고 체계적인 소프트웨어\u0026rsquo;보다 ‘돌아가는 소프트웨어\u0026rsquo;에 초점을 맞춘다. 관심사를 분리하는 작업은 프로그램만이 아니라 프로그래밍 활동에서도 마찬가지로 중요하다. 문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. ‘깨끗하고 체계적인 소프트웨어’라는 다음 관심사로 전환하지 않는다. 게다가 많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 우려한다. 큰 그림을 이해하려면 이 클래스 저 클래스 수없이 넘나들어야 한다고 걱정한다. 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품의 수는 비슷하다. 어느 시스템이든 익힐 내용은 그 양이 비슷하다. 규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다. 이런 복잡성을 다루려면 체계적인 정리가 필수다. 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다. 응집도 # 클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. ‘함수를 작게, 매개변수 목록을 짧게\u0026rsquo;라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다. 응집도를 유지하면 작은 클래스 여럿이 나온다. # 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 큰 함수의 일부를 작은 함수로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다면? 그렇다면 변수 네 개를 새 함수에 인수로 넘겨야 옳을까? 아니다. 네 변수를 클래스 인스턴스 변수로 승격하면 새 함수는 인수가 필요없다. 불행히도 이렇게 하면 클래스가 응집력을 잃는다. 몇몇 함수만 사용하는 인스턴스 변수가 늘어나기 때문이다. 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리하면 되지 않을까? → 정답 클래스가 응집력을 잃는다면 쪼개라. 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 클래스를 쪼개고 리팩터링하면 길이는 늘어난다. 그 이유는, 리팩토링한 프로그램은 더 길고 서술적인 변수 이름을 사용하며, 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 사용하고, 가독성을 높이고자 공백을 추가하고 형식을 맞추었기 때문 변경하기 쉬운 클래스 # 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다. 어떤 변경이든 클래스에 손을 대면 다른 코드를 망가뜨릴 잠정적인 위험이 존재한다. 경험에 의하면 클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다. 예시 SQL 클래스의 인터페이스를 각각 SQL 클래스의 파생 클래스로 만듬 클래스마다 단 하나의 메서드를 가지는데 이 방식이 좋은지 잘 모르겠음.. 변경으로부터 격리 # 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.\n상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다.\n그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.\n상세한 구현에 의존하는 코드는 테스트가 어렵다.\n인터페이스를 따라 테스트용 목 클래스를 구현하여 테스트에 사용할 수 있다.\n시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.\n결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.\n시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 쉬워진다.\n","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/10-class/","section":"Posts","summary":"클린코드 10장 클래스","title":"클린코드 10장 클래스"},{"content":" 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다 - 레이 오지\n도시를 세운다면? # 한사람의 힘으로는 무리다. 도시에 큰 그림을 그리는 사람이 있으면 작은 사항에 집중하는 사람들도 있다. 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다. 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 구성요소는 효율적으로 돌아간다. 소프트웨어도 도시처럼 구성한다. 그런데 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다. 시스템 제작과 시스템 사용을 분리하라 # 제작과 사용은 아주 다르다. 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다. 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 불행히도 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다. 준비 과정 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤섞는다. const getSercvice = () =\u0026gt; { if (service === null) { service = new MyService(...); } return service } 위 코드는 Lazy Initialization 이라는 기법이다.\n장점\n실제로 필요할 때 까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않고, 그만큼 애플리케이션을 시작하는 시간이 빨라진다. 단점\n하지만 이 함수는 MyService 생성자 인수에 명시적으로 의존한다. 런타임 로직에서 MyService 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안된다. 테스트도 문제다. Myservice가 무거운 객체라면 단위테스트에서 getService를 호출하기 전에 테스트용 목 객체를 할당해야 한다. 또한 일반 런타인 로직에서 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로를 테스트해야 한다. 무엇보다 MyService가 모든 상황에 적합한 객체인지 모른다는 사실이 가장 큰 우려다. 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제는 아니다.\n하지만 많은 애플리케이션이 이처럼 좀스러운 설정 기법을 수시로 사용한다.\n그래서 전반적인 설정 방식이 애플리케이션 곳곳에 흩어진다. 모듈성은 저조하며 대개 중복이 심각하다.\n체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대 안 된다.\n객체를 생성하거나 의존성을 연결할때도 마찬가지다.\n설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.\n또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.\nmain 분리 # 시스템 생성과 시스템 사용을 분리하는 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. 이 방법은 제어 흐름을 따라가기 쉽다. main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다. 즉, 애플리케이션은 메인이나 객체가 생성되는 과정을 전혀 모른다. 단지 모든 객체가 적절히 생성되었다고 가정한다. 팩토리 # 물론 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. 추상 팩토리 패턴 사용. https://refactoring.guru/ko/design-patterns/abstract-factory 객체 세트를 생성하는 패턴 추상 팩토리는 생성 역할을 하는 팩토리 클래스의 공통 인터페이스를 정의함 의존성 주입 # 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입이다.\n제어 역전 기법을 의존성 관리에 적용한 매커니즘\n새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.\n의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다.\n대신에 이런 책임을 다른 전담 매커니즘에 넘겨야만 한다. 그렇게 제어를 역전시킨다.\n초기 설정은 시스템 전체에서 필요하므로 대개 ‘책임질\u0026rsquo; 매커니즘으로 ‘main’ 루틴이나 특수 컨테이너를 사용한다.\n의존성 주입에서 클래스는 스스로 의존성을 해결하지 않는다. 완전히 수동적이다.\n대신에 의존성을 주입하는 방법으로 설정자 메서드나 생성자 인수를 제공한다.\n확장 # ‘처음부터 올바르게\u0026rsquo; 시스템을 만들 수 있다는 믿음은 미신이다.\n대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.\n내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.\n이것이 반복적이고 점진적인 애자일 방식의 핵심이다.\n테스트 주도 개발, 리팩터링, 깨끗한 코드는 코드수준에서 시스템을 조정하고 확장하기 쉽게 만든다.\n하지만 시스템수준에서는?\n소프트웨어 시스템은 물리적인 시스템과 다르다.\n관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.\n소프트웨어 시스템은 ‘수명이 짧다\u0026rsquo;는 본질로 인해 아키텍처의 점진적인 발전이 가능하다.\n횡단 관심사 # 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다. 현실적으로 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 횡단 관심사라는 용어가 나온다. AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다. AOP에서 관점이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 잇게 바꿔야 한다\u0026quot;라고 명시한다. 명시는 간결한 선언이나 프로그래밍 매커니즘으로 수행한다. 테스트 주도 시스템 아키텍처 구축 # 관점으로 관심사를 분리하는 방식은 그 위력이 막강하다.\n코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.\n건축가는 BDUF(구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법) 방식을 취한다.\n물리적 구조는 일단 짓기 시작하면 극적인 변경이 불가능한 탓이다.\n소프트웨어 역시 나름대로 형체가 있지만, 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다.\n다시말해, 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다는 말이다.\n의사결정을 최적화하라 # 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. 도시든 소프트웨어 프로젝트든, 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다. 가장 적합한 사람에게 책임을 맡기면 좋다. 명백한 가치가 있을 때 표준을 현명하게 사용하라. # 나는 업계에서 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례를 많이 봤다. 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 워래 표준을 제정한 목적을 잊어버리기도 한다. 결론 # 시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품품질이 떨어진다. 버그가 숨어들기 쉬워지고, 스토리를 구현하기 어려워지는 탓이다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다. 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자. 의존성 주입, 추상 팩토리, aop 사용하는 이유는 이해함. 다른 얘기들은 아직 별로 와닿진 않는다.\n","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/11-system/","section":"Posts","summary":"클린코드 11장 시스템","title":"클린코드 11장 시스템"},{"content":"창발적 설계로 깔끔한 코드를 구현하자 # 착실하게 따르기만 하면 우수한 설계가 나오는 간단한 규칙 네 가지가 있다면? 네 가지 규칙을 따르면 코드 구조와 설계를 파악하기 쉬워진다면? 그래서 SRP, DIP와 같은 원칙을 적용하기 쉬워진다면? 네 가지 규칙이 우수한 설계의 창발성을 촉진한다면? 켄트 백이 제시한 단순한 설계 규칙 네 가지는 다음과 같다. 모든 테스트를 실행한다. 중복을 없앤다. 프로그래머 의도를 표현한다. 클래스와 메서드 수를 최소로 줄인다. 위 순서는 중요도 순이다. 단순한 설계 규칙 1: 모든 테스트를 실행하라 # 테스트가 불가능한 시스템은 검증이 불가능하다. 검증이 불가능한 시스템은 절대 출시해선 안 된다. 다행스럽게도, 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다. 테스트 케이스가 많을수록 개발자는 테스트가 쉽게 코드를 작성한다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다. 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 그러므로 앞서와 마찬가지로, 테스트 케이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고 의존성 주입, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다. “테스트 케이스를 만들고 계속 돌려라\u0026quot;라는 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다. 즉, 테스트 케이스를 작성하면 설계 품질이 높아진다. 단순한 설계 규칙 2~4: 리팩터링 # 테스트 케이스를 모두 작성했다면 이제 코드와 클래스를 정리해도 된다. 코드를 점진적으로 리팩터링한다. 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하고.. 등등 코드를 정리하면서 시스템이 깨질까봐 걱정할 필요가 없다. 테스트 케이스가 있으니까. 중복을 없애라 # 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문에 설계에서 커다란 적이다. 중복은 여러가지 형태로 표출된다. 똑같은 코드는 당연히 중복이다. 비슷한 코드는 더 비슷하게 고쳐주면 리팩토링이 쉬워진다. 표현하라 # 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안 문제에 빠져 코드를 구석구석이해하니까. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다. 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다. 코드를 변경하면서 버그의 싹을 심지 않으려면 유지보수 개발자가 시스템을 제대로 이해해야 한다. 그러므로 코드는 개발자의 의도를 분명히 표현해야 한다. 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다. 우선 좋은 이름을 선택하자. 둘째로 함수와 클래스 크기를 가능한 줄인다. 표준 명칭을 사용한다. 단위 테스트를 꼼꼼히 작성하자. 테스트 케이스는 소위 ‘예제를 보여주는 문서\u0026rsquo;이다. 다시 말해, 잘 만든 테스트 케이스를 읽어보면 클래스의 기능이 한눈에 들어온다. 표현력을 높이는 가장 중요한 방법은 노력이다. 흔히 코드만 돌린 후 다음 문제로 가는 사례가 너무도 흔하다. 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만들려고 고민하자. 클래스와 메서드 수를 최소로 줄여라 # 중복을 제거하고, 의도를 표현하고, SRP를 준수한다는 기본적인 개념도 극단으로 치달으면 득보다 실이 많아진다. 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만드는 사례도 없지 않다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 결론 # 이 책에서 소개하는 기법은 수십년 동안 쌓은 경험의 정수이니 그냥 따르도록. ","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/12-emergence/","section":"Posts","summary":"클린코드 12장 창발성","title":"클린코드 12장 창발성"},{"content":"애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 늘어나는 추세다. 하지만 우리 분야에 테스트를 추가하려고 급하게 서두르는 와중에 많은 프로그래머들이 제대로 된 테스트 케이스를 작성해야 한다는 좀 더 미묘한 사실을 놓쳐버렸다.\nTDD 법칙 세가지 # 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 위 규칙을 따라 일하면 매일 수백, 수천개에 달하는 테스트케이스가 나온다. 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.\n깨끗한 테스트 코드 유지하기 # 몇몇 팀에서는 단위 테스트에서는 실제 코드의 컨벤션 규칙을 깨도 좋다는 허가장을 준다. ‘지저분해도 빨리\u0026rsquo;가 주제어 였다. 지저분한 테스트코드를 작성하는 것과 테스트를 안 하는 것은 오십보 백보이다. 아니, 오히려 지저분한 테스트 코드 작성이 더 못하다. 실제 코드가 진화하면 테스트 코드도 변해야 한다. 테스트 코드가 지저분할수록 변경하기 어렵다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸린다. 새 버전을 출시할 때마다 팀이 테스트 케이스를 유지하고 보수하는 비용도 늘어난다. 점차 불만이 생기고, 테스트 슈트를 폐기하지 않으면 안 되는 상황에 처한다. 하지만, 테스트 슈트가 없으면 개발자는 자신이 수정한 코드가 제대로 도는지 확인할 수 없다. 시스템을 수정하면 다른쪽이 안전하다는 사실을 검증하지 못한다. 결함율이 높아지고, 개발자는 변경을 주저한다. 변경하면 득보다 해가 크다 생각해 더 이상 코드를 정리하지 않는다. 실패를 초래하는 원인은 테스트 코드를 막 짜도 좋다고 허용한 결정이다. 테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. # 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다. 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트이다. 테스트가 없으면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도 테스트 케이스가 없으면 개발자는 변경을 주저한다. 테스트 케이스가 있다면 공포는 사실상 사라진다. 아키텍처가 부실하더라도 별다른 우려 없이 변경할 수 있다. 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트케이스가 있으면 변경이 쉬워지기 때문이다. 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. 테스트 코드가 지저분할수록 실제 코드도 지저분해진다. 결국 테스트 코드를 잃어버리고 실제 코드도 망가진다. 깨끗한 테스트 코드 # 깨끗한 테스트 코드를 만들려면? 가독성이 필요하다. 어쩌면 실제 코드보다 더 가독성이 중요하다. 표현력 테스트 당 assert 하나 # 함수마다 assert 문을 단 하나만 사용해야 한다고 주장하는 사람들이 있다. 가혹한 규칙이라 여길지도 모르지만 확실히 장점이 있다. assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 개념이 같다면 한 함수에 assert를 여러개 써도 괜찮다. 단지 assert문의 개수를 최대한 줄여야 한다는 것에는 동의함 테스트 함수마다 한 개념만 테스트하라 F.I.R.S.T # 깨끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST이다. F: Fast 테스트는 빨라야한다. 느리면 자주 돌릴 엄두가 나지 않는다. I: Independent 각 테스트는 서로 의존하면 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. R: Repeatable 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA, 심지어 네트워크에 연결되지 않은 환경에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. S: Self-Validating 테스트는 bool값으로 결과를 내야 한다. 성공 아니면 실패 테스트가 스스로 성공, 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. T: Timely 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 결론 # 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다. 어쩌면 실제 코드보다 중요할 수 있다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 테스트코드를 지속적으로 깨긋하게 관리하자. 표현력을 높이고 간결하게 정리하자. ","date":"2022 / 05 / 18","permalink":"/posts/study/clean-code/09-unit-test/","section":"Posts","summary":"클린코드 9장 단위 테스트","title":"클린코드 9장 단위 테스트"},{"content":"깨끗한 코드와 오류처리는 연관성이 있다. 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.\n오류 코드보다 예외를 사용하라 # 오류 코드를 리턴하고 호출문에서 리턴받은 오류 코드를 확인하여 처리하는 방식은 호출자 코드가 복잡해진다. 함수를 호출한 즉시 오류를 확인해야 하기 때문이다. 오류가 발생하면 예외를 던지는 편이 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와 뒤섞이지 않으니까. Try-Catch-Finally 문부터 작성하라 # 어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 미확인 예외를 사용하라 # 확인된 예외가 반드시 필요하지는 않다. 확인된 예외는 OCP를 위반한다. 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다. 솔직히 잘 모르겠다. 예외에 의미를 제공하라 # 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 호출자를 고려해 예외 클래스를 정의하라 # 외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 api를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 또한 감싸기 클래스에서 외부 api를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램 테스트하기도 쉽다. // ACMEPort가 외부 api 인 상황에서 LocalPort 클래스를 생성하여 // 외부 api를 감싸고 예외처리를 추가함 class LocalPort { #innerPort: ACMEPort; constructor() { this.#innerPort = new ACMEPort(); } open = () =\u0026gt; { try { this.#innerPort.open(); } catch (e) { throw new PortDeviceFailure(e); } ... }; } 정상 흐름을 정의하라 # 특수 사례 패턴 → 클라이언트 코드가 예외적인 상황을 처리할 필요가 없도록 클래스나 객체를 조작해 특수사례를 처리하는 방식 // employ의 식비를 총계에 더한다. // 만약 식비를 비용으로 청구하지 않았다면 일일 기본 식비를 총계에 더한다. function getTotal(employList) { let m_total = 0; for (let employee of employList) { const expenses = expenseReportDAO.getMeals(employee.getID()); try { m_total += expenses.getTotal(); } catch { m_total += getMealPerDiem(); } } return m_total; } // 하지만 expense.getTotal 함수의 기본값으로 일일 기본 식비를 반환한다면 // 클라이언트 코드에서 예외 상황을 처리할 필요가 없어진다. function getTotal(employList) { let m_total = 0; for (let employee of employList) { const expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); } return m_total; } null을 반환하지마라 # null을 반환하면 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션이 된다. Null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. 많은 경우 특수사례 패턴이 좋은 해결책이다. null을 전달하지 마라 # 메서드로 null을 전달하는 방식은 더 나쁘다. 결론 # 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다. ","date":"2022 / 05 / 14","permalink":"/posts/study/clean-code/07-error/","section":"Posts","summary":"클린코드 7장 오류 처리","title":"클린코드 7장 오류 처리"},{"content":"시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. 때로는 어떤 식으로든 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다. 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.\n외부 코드 사용하기 # 인터페이스 제공자와 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. 자바의 Map 예시 → 경계 인터페이스인 Map을 Sensors라는 커스텀 클래스로 숨기고 Sensors에서 필요한 인터페이스를 제공함. 외부 패키지를 자신의 클래스로 감싸서 인터페이스를 다시 정의하려는 의도인 것 같은데 갠적으로 이 예시에선 제네릭 쓰는게 나아보인다. 경계 살피고 익히기 # 외부 패키지 테스트는 우리 책임이 아니다. 하지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익혀보자 → 학습 테스트 학습 테스트는 공짜 이상이다 # 학습 테스트는 이해도를 높여줄 뿐만 아니라 패키지가 예상대로 도는지 검증도 한다. 통합한 이후라고 하더라도 패키지가 우리 코드와 항상 호환되리라는 보장은 없다. 패키지 새 버전이 나올 때 마다 새로운 위험이 생긴다. 학습테스트를 통해 위험을 감지 할 수 있다. 아직 존재하지 않는 코드를 사용하기 # 경계와 관련해 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다. 자체적으로 인터페이스를 정의하자. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 코드 가독성도 높아지고 코드 의도도 분명해진다. 외부 api가 완성된 후에는 어댑터 패턴으로 api 사용을 캡슐화한다. 이와 같은 설계는 테스트도 아주 편하다. 깨끗한 경계 # 경계에서는 흥미로운 일이 많이 벌어진다. 변경이 대표적이다. 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다. 엄청난 시간과 노력과 재작업을 요구하지 않는다. 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의하자. 경계에 위치하는 코드는 깔끔히 분리하고, 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 좋다. ","date":"2022 / 05 / 14","permalink":"/posts/study/clean-code/08-boundaries/","section":"Posts","summary":"클린코드 8장 경계","title":"클린코드 8장 경계"},{"content":"변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.\n충동이든 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어서다.\n그렇다면 어째서 수많은 프로그래머가 get함수와 set함수를 당연하게 공개해 비공개 변수를 외부로 노출하는가?\n자료 추상화 # public class Point1 { public double x; public double y; } public class Point2 { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); } 변수를 Private으로 선언하더라도 각 값마다 조회(get)함수와 설정(set)함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지는게 아니다. 구현을 감추려면 추상화가 필요하다. 조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되는게 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회/설정 함수만으로 추상화가 이뤄지는게 아니다. 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 고민해야 한다. 아무 생각없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다. 자료/객체 비대칭 # 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 반대쪽도 참이다. 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 모든 클래스를 고쳐야 한다. 다시말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체지향에서 쉽다. 분별있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료구조와 절차적인 코드가 가장 적합한 상황도 있다. 디미터 법칙 # 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다. 그러면 내부 구조를 노출하는 셈이니까. 기차 충돌 # final String outputDir = ctxt.getOptions().getScratchDir().getAbsoultePath() 위와 같은 코드를 기차 충돌이라 부른다. 여러 객체가 한 줄로 이어진 기차처럼 보이기 때문이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 위 코드는 다음과 같이 나누는 편이다. Options opts = ctxt.getOptions(); File scratchDir = opts.getScratchDir(); final String outputDir = scratchDir.getAbsolutePath(); 위 예제가 디미터 법칙을 위반할까? ctxt, Options, ScratchDir이 객체인지 자료구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 위 예제는 조회함수를 사용하기 때문에 혼란스럽다 코드를 다음과 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. final String outputDir = ctxt.options.scratchDir.absolutePath; 자료구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 문제는 훨씬 간단해진다. 잡종 구조 # 이런 혼란으로 말미암아 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다. 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다. 이러한 잡종 구조는 새로운 함수는 물론이고 새로운 자료구조도 추가하기 어렵다. 구조체 감추기 # 위 코드를 어떻게 개선할 수 있을까? ctxt.getAbsolutePathOfScratchDirectoryOption(); ctxt.getScratchDirectoryOption().getAbsolutePath(); 둘다 맘에 들지 않는다. 절대 경로가 필요한 원인을 찾자. 절대 경로를 어디서 쓰는가? 위 예제에서는 임시파일을 생성하기위해 절대 경로를 가져왔다. ctxt 객체에 임시 파일을 생성하라고 시키는건 어떨까? BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); 객체에 맡기기 적합한 임무이다. ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다. ","date":"2022 / 05 / 10","permalink":"/posts/study/clean-code/06-object-data-structure/","section":"Posts","summary":"클린코드 6장 객체와 자료구조","title":"클린코드 6장 객체와 자료구조"},{"content":"프로그래머라면 형식을 깔금하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다.\n형식을 맞추는 목적 # ‘돌아가는 코드\u0026rsquo;가 개발자의 일차적인 의무라 여길지도 모른다. 하지만 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. 그런데 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다. 적절한 행 길이를 유지하라 # 7개의 자바 라이브러리를 조사한 결과 파일의 길이가 500줄을 넘지 않고, 대부분 200줄 정도인 파일로 구축되어 있었다. 신문 기사처럼 작성하라 # 독자는 위에서 아래로 기사를 읽는다. 최상단에 기사를 몇 마디로 요약하는 표제가 나온다. 첫 문단은 전체 기사 내용을 요약한다. 세세한 사실은 숨기고 커다란 그림을 보여준다. 쭉 읽으며 내려가면 세세한 사실이 조금씩 드러나고, 기타 세부사항이 나온다. 소스파일도 신문 기사와 비슷하게 작성하자. 소스파일의 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈수록 의도를 세세하게 묘사하자. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 # 거의 모든 코드는 왼쪽에서 오른쪽으로, 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나태내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 세로 밀집도 # 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다. 함수 연관 관계와 동작 방식을 이해하려고 이 함수에서 저 함수로 오가며 소스 파일을 위아래로 뒤지는 등 뱅뺑이를 돌았으나 결국은 미로 같은 코드 때문에 혼란만 가중된 경험이 있는가? 가로 형식 맞추기 # 80자에서 120자 사이 권장 ","date":"2022 / 05 / 08","permalink":"/posts/study/clean-code/05-convention/","section":"Posts","summary":"클린코드 5장 형식 맞추기","title":"클린코드 5장 형식 맞추기"},{"content":" 나쁜 코드에 주석을 달지마라. 새로 짜라. - 브라이언 w커니핸 플라우거\n잘 달린 주석은 유용하지만, 경솔하고 근거없는 주석은 코드를 이해하고 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨린다.\n주석은 쉰들러리스트가 아니다. 순수하게 선하지 못하다. 코드 자체가 표현력이 풍부하다면, 주석은 필요하지 않다. 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다. 주석은 언제나 실패를 의미한다.\n주석은 오래될수록 코드에서 멀어진다. 오래될수록 완전히 그릇될 가능성도 있다. 프로그래머들이 주석을 유지보수하긴 현실적으로 불가능하다. 주석이 언제나 코드를 따라가진 않는다.\n주석을 엄격하게 관리하느니, 코드를 깔끔하게 정리하고 표현력을 강화하는 방향으로 에너지를 쏟아라. 부정확한 주석은 아예 없는 것 보다 나쁘다.\n진실은 한 곳에 존재한다. 바로 코드다. 코드만이 자기가 하는 일을 진실되게 말한다.\n주석은 나쁜 코드를 보완하지 못한다. # 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다. 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하며 어수선하고 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라. # // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if((employee.flags \u0026amp; HOURY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)) --- if(employee.isEligibleForFullBenefits()) 위 코드보다 아래 코드가 훨씬 낫다. 주석이 없어도 코드로 의도를 표현할 수 있다. 좋은 주석 # 법적 정보 정보 제공 // kk:mm:ss EEE, MMM, dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile( ... ) 위 코드는 정규표현식이 시각과 날짜를 뜻한다고 설명한다. 이왕이면 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 좋고 깔끔하겠다. 의도를 설명하는 주석 의미를 명료하게 밝히는 주석 TODO 주석 중요성을 강조하는 주석 위 주석들 중 내 생각에 꼭 필요한건 법적정보와 TODO 뿐인 것 같다. 나머지는 없앨 수 있다면 없애는게 더 낫다.\n나쁜 주석 # 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 시간낭비다. 같은 이야기를 중복하는 주석 코드 내용을 그대로 중복설명 오해할 여지가 있는 주석 의무적으로 다는 주석 javadocs 이력을 기록하는 주석 git 쓰니까 필요없음 함수나 변수로 표현할 수 있다면 주석을 달지 마라 생략 대다수의 주석은 나쁘다. 코드로 의도를 표현하자.\n","date":"2022 / 05 / 07","permalink":"/posts/study/clean-code/04-comment/","section":"Posts","summary":"클린코드 4장 주석","title":"클린코드 4장 주석"},{"content":"사이드로 만들 사이트 인증 쪽 하다가 배운 것 정리\nsupabase란? # https://supabase.com/\n파이어베이스 대체제로 나온 서비스이다. 파이어베이스보다 좋은 점은 PostgreSQL을 데이터베이스로 사용이 가능하다. 파이어베이스는 db 쿼리가 좋지 않은 거로 아는데, 이 부분에선 PostgreSQL을 쓸 수 있는 supabase가 확실히 낫다. 그리고 셀프 호스팅으로 저렴하게 사용할 수 있어서 호감이다.\n이 포스팅에서 다룰 인증은 파이어 베이스에도 있는 기능이다. 아마 사용방식도 비슷할 것 같다.\n프로젝트 설정 # https://app.supabase.io/\nsupabase에서 프로젝트 생성 후, authentication 설정을 들어간다.\n사이트 url과 jwt expiry를 설정하자. jwt 만료시간은 accessToken에 적용된다. refreshToken은 왜 없는지 궁금했는데, jwt 토큰 형식이 아니었다.\n{ \u0026#34;provider_token\u0026#34;: null, \u0026#34;access_token\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjUxNzU1ODkyLCJzdWIiOiJjYjE5NDliNy0yNzJkLTQ2OWItYjRiYS01M2RhMDE4YTllMmIiLCJlbWFpbCI6InNvc28wMWRldkBnbWFpbC5jb20iLCJwaG9uZSI6IiIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIiwicHJvdmlkZXJzIjpbImVtYWlsIl19LCJ1c2VyX21ldGFkYXRhIjp7fSwicm9sZSI6ImF1dGhlbnRpY2F0ZWQifQ.6wch2tYoc3ynLl_RxM7ZGFH4DrREOGDO8HyV-H2-T6o\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;expires_at\u0026#34;: 1651755893, \u0026#34;refresh_token\u0026#34;: \u0026#34;YfHHAXSBlltxLoJ4kbXU5Q\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;user\u0026#34;: { ... } } 위 포맷으로 세션 정보를 가져온다. refresh 토큰은 jwt 토큰이 아닌, 그냥 키값이었다. 그리고 세션을 갱신할 때마다 refresh_token도 변경된다. 평소에 사용하던 jwt 토큰의 refresh 방식이 아니라 일회용 키값을 발급해주는 식인 것 같은데 만료가 되는지는 잘 모르겠다.\n프론트엔드 설정 # import { createClient } from \u0026#34;@supabase/supabase-js\u0026#34;; const supabaseUrl = import.meta.env.VITE_SUPABASE_URL; const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY; export const supabase = createClient(supabaseUrl, supabaseAnonKey); @supabase/supabase-js js 용 supabase 라이브러리를 설치 후, supabaseClient 인스턴스를 생성한다.\nawait supabase.auth.signIn({ email }); 그리고 생성한 supabase 인스턴스에 auth.signIn() 으로 로그인을 요청할 수 있다. 이메일만 설정하면 자동으로 매직 링크 로그인 방식으로 인지하고 이메일을 보낸다.\n이메일의 기본 포맷은 위와 같다. 링크 주소는 https://ycfqxoxuzltvyozzmbdt.supabase.co/auth/v1/verify?token=oseidldaadtnhomfwdme\u0026amp;type=magiclink\u0026amp;redirect_to=http://localhost:3000/\n인데, token이 리프레쉬 토큰이고, 액세스 토큰을 발급해서 redirect 주소로 쿼리스트링과 함께 보내주는 듯 하다.\n// 리프레쉬 supabase.auth.refreshSession(); // 로그아웃 supabase.auth.signOut(); 리프레쉬와 로그아웃 호출은 위와 같이 메서드를 호출 하면 된다.\naxios 설정 # supabase 대시보드에서 액세스 jwt 토큰의 시크릿 키를 제공해 주기 때문에, 독자적으로 accesskey verify를 할 수 있다. 그래서 나는 supabase를 인증서버로만 사용하고, 비즈니스 로직을 다룰 백엔드 서버는 따로 두려고 한다.\n프론트에서 supabase의 액세스키를 헤더에 실어서 백엔드로 보내고, 백엔드에선 jwt를 verify하고 payload에 담긴 유저 id(sub)으로 로직을 수행한다.\nimport axios, { Axios, AxiosError } from \u0026#34;axios\u0026#34;; import { supabase } from \u0026#34;@/config/supabaseClient\u0026#34;; import { Session, SupabaseClient } from \u0026#34;@supabase/supabase-js\u0026#34;; class API { api: Axios; supabase: SupabaseClient; constructor(supabase: SupabaseClient) { this.api = axios.create(); this.supabase = supabase; this.setBaseURL(); this.setAuthorization(this.supabase.auth.session()); this.setInterceptor(); } setBaseURL() { this.api.defaults.baseURL = import.meta.env.VITE_BASE_URL; } setAuthorization(session: Session | null) { const accessToken = session?.access_token; const authorization = accessToken ? `Bearer ${accessToken}` : \u0026#34;\u0026#34;; this.api.defaults.headers.common[\u0026#34;Authorization\u0026#34;] = authorization; } setInterceptor() { this.api.interceptors.response.use( (res) =\u0026gt; res, async (error: AxiosError) =\u0026gt; { const { config, response } = error; if (response?.status === 401 \u0026amp;\u0026amp; this.supabase.auth.session()) { const accessToken = await this.refresh(); if (accessToken) { return axios({ ...config, headers: { Authorization: `Bearer ${accessToken}`, }, }); } } return Promise.reject(error); } ); } async refresh() { const response = await this.supabase.auth.refreshSession(); this.setAuthorization(this.supabase.auth.session()); return response.data?.access_token; } logout() { this.supabase.auth.signOut(); } } export const apiSetting = new API(supabase); export const api = apiSetting.api; 내 백엔드에 http 요청을 보내기 위해 axios 인스턴스도 따로 설정했다.\n로그인하면 setAuthorization 메서드로 헤더에 액세스토큰을 설정하고, 만약 백엔드에서 401 에러를 반환하면, 인터셉터에서 supabase에서 제공하는 refresh 메서드를 실행 후 재요청한다.\n백엔드는 nestjs 다시 공부하고 추가 예정\n후기 # 외부 서비스로 인증하니 너무 쉽고 편하게 구현할 수 있어서 좋았다. 전에 인증 서비스로 auth0가 유명하길래 봤는데, 그건 너무 비싸서 사용할 엄두가 안 났었다. supabase는 인증서버로만 사용한다면 사실상 평생 무료처럼 보인다. 앞으로 사이드프로젝트에서 인증은 무조건 이거 쓸 것 같다.\n","date":"2022 / 05 / 05","permalink":"/posts/dev/supabase_auth/","section":"Posts","summary":"supabase으로 매직링크 사용자 인증","title":"supabase으로 매직링크 사용자 인증"},{"content":"트위터 계정을 만들었다.\n계기는 개발바닥 유튜브에서 향로님이 개발관련 정보를 어디서 얻느냐는 질문에 트위터라고 답했는데, 되게 의외라서 기억에 남았다. 트위터에서 개발을?\n오늘 가입하고 둘러봤는데 볼게 많아서 너무 재밌다. 생각보다 고연차 개발자분들이 많아서 신기했다.\n아이패드 사고 미디엄 처음 구독했을 때와 비슷한 느낌이다. 이 기분이 오래갔으면 좋겠다.\n내 트위터 주소 - https://twitter.com/soso01_dev\n","date":"2022 / 05 / 03","permalink":"/posts/etc/%ED%8A%B8%EC%9C%84%ED%84%B0_%EA%B3%84%EC%A0%95_%EC%83%9D%EC%84%B1/","section":"Posts","summary":"트위터 계정 생성","title":"트위터 계정 생성"},{"content":"작게 만들어라. # 함수를 만드는 첫째 규칙은 ‘작게\u0026rsquo;이고, 둘째도 ‘작게\u0026rsquo;다. 켄트 백의 프로그램 Sparkle은 모든 함수가 2~4줄 정도였고, 각 함수가 너무도 명백했다. 블록과 들여쓰기 # if / else문, while문 등에 들어가는 블록은 한줄이어야 한다. 대게 거기서 함수를 호출한다. 이 말은 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 의미이다. 한 가지만 해라! # 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야한다. ‘한 가지\u0026rsquo;란? 추상적인 수준의 하나의 작업을 의미한다. 예를 들어 ‘물마시기\u0026rsquo;는 컵을 들고 → 입에 가져다 대고 → 마신다 라는 과정을 거치지만 ‘물을 마신다\u0026rsquo;라는 추상적 개념으로 하나의 작업으로 볼 수 있음. 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! # 함수가 확실히 ‘한 가지\u0026rsquo; 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵기 때문이다. 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다. 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. switch 문 # 본질적으로 switch 문은 N가지를 처리한다. 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법이 있다. 다형성을 이용하자. switch문을 추상 팩토리에 숨기고, 파생 클래스가 함수를 실행하도록 하자. 서술적인 이름을 사용하라! # 워드가 말했던 클린 코드의 원칙, “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 클린 코드라 불러도 된다.” 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이 원칙을 달성함에 있어 이미 절반은 성공한다. 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다. 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다. 함수 인수 # 이상적인 인수는 0개다. 다음은 1개이고, 3개 이상은 가능한 피하자. 테스트 관점에서 보면 인수는 어렵다. 갖가지 인수 조합으로 함수를 검증하는 테스트 케이스를 작성한다고 상상해보자. 인수가 0개이면 간단하다. 3개이상이면 상당히 부담스럽다. 출력 인수는 입력 인수보다 이해하기 어렵다. 흔히 우리는 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받는다는 개념에 익숙하다. 대개 함수에서 인수로 결과를 받으리라 기대하지 않는다. 단항 형식 함수에 인수를 1개 넘기는 이유로 가장 흔한 경우 두가지이다. 인수에 질문을 던지는 경우 인수를 뭔가로 변환해 결과를 반환하는 경우 드물지만 단한 함수 형식 이벤트도 사용함. 플래그 인수 플래그 인수는 끔찍하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이나 마찬가지이다. 이항 함수 인수가 2개이면 1개인 경우보다 이해하기 어렵다. new Point(x, y)와 같은 경우는 적절하다. x, y는 자연적인 순서를 가진다. 하지만 다른 경우 인수간에 자연적 순서가 없이, 인위적인 순서를 기억해야 하는 불편함을 가진다. 이항 함수는 프로그램을 짜다보면 불가피한 경우도 생기지만, 가능하다면 단항함수로 바꾸도록 노력하자. 인수 객체 makeCircle(x, y, radius)를 인수 객체를 사용해 makeCircle(point, radius)로 고칠 수 있다. 사이드 이펙트를 일으키지마라 # 사이드 이펙트는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓을 하니까. 사이드 이펙트는 ‘시간적인 결합\u0026rsquo;이나 ‘순서 종속성\u0026rsquo;을 초래할 수 있다. 명령과 조회를 분리하라! # 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 혼란을 초래한다. 오류 코드보다 예외를 사용하자 # if (deletePage(page)) === E_OK) 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. ?? 위 코드는 여러 단계로 중첩되는 코드를 야기한다. 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다. try / catch 블록은 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try / catch 블록을 별도 함수로 뽑아내는 편이 좋다. 오류 처리도 한 가지 작업이다. 함수는 ‘한 가지\u0026rsquo; 작업만 해야 한다. 오류처리도 작업에 속한다. 오류를 처리하는 함수는 오류만 처리해야 마땅하다. 반복하지 마라! # 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손봐야 한다. 함수를 어떻게 짜죠? # 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 함수도 마찬가지로 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드는 중복된다. 그 코드를 테스트하는 단위테스트 코드를 만들고 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거해야 한다. 최종적으로 이 장에서 설명한 규칙을 따르는 함수가 얻어진다. 처음부터 짜내는건 어렵다. 결론 # 함수는 언어에서 동사며, 클래스는 명사다. 마스터 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다. 이 장에서 함수를 잘 만드는 기교를 소개했지만, 진짜 목표는 시스템이라는 이야기를 잘 풀어나가는 데 있다는 사실을 명심하자. ","date":"2022 / 04 / 30","permalink":"/posts/study/clean-code/03-function/","section":"Posts","summary":"클린코드 3장 함수 요약","title":"클린코드 3장 함수 요약"},{"content":"**클라이언트 측 아키텍처 기본**\nhttps://khalilstemmler.com/articles/client-side-architecture/introduction/\n리액트 애플리케이션의 아키텍처는 널리 인정되어 있는 표준이 없다. 매번 프로젝트를 시작하는 방법, 사용할 프레임워크, 상태 관리 방법, 번들로 제공되는 방법, 접근성 및 배포를 시작하는 방법까지 매번 선택해야 한다.\n이 게시글은 이러한 고민에서 도움이 될 클라이언트 측 아키텍처 원칙을 소개한다.\n아키텍처 # MVC, MVP 는 너무 일반적이다. # 훌륭한 아키텍처지만 불행히 둘 다 너무 일반적인 문제를 겪는다.(generic 일반적?)\nMVC와 MVP에서 모두 모델이 너무 많은 책임을 진다는 것이다. 결과적으로 개발자는 어떤 도구가 어떤 작업을 담당하는지 모르게 된다.\nMVC와 MVP의 모델은 모호하다. 따라서 작업에 맞는 도구를 맞추는 것이 퍼즐처럼 느껴진다.\n모델의 작업 # 상태관리 대부분의 앱에는 상태를 가져오고, 업데이트하고, 변경될 때 뷰를 다시 렌더링 할 수 있도록 반응성을 구성할 방법이 필요하다. 네트워킹 및 데이터 가져오기 모델 동작 (도메인, 앱 또는 상호 작용 논리) 인증 및 권한 부여 논리 클린 아키텍처 # 테스트 가능하고 유연한 방식으로 백엔드를 구성하는 방법에 대해 많은 정보를 제공한다. 모델을 인프라, 애플리케이션, 도메인 레이어로 분할하여 관심사 분리 설계 원칙을 실행하고 아키텍처에 대해 훨씬 더 쉽게 추론할 수 있다. 이와 같은 계층 아키텍처는 단순한 단일 계측 아키텍처보다 복잡하지만, 많은 이점이 있다. 스택의 어느 레이어에 어떤 도구가 필요한지 매우 명확하게 한다. 문제를 분리하여 유지하고 앱 및 도메인 레이어 코드 단위를 테스트 가능하게 유지할 수 있다. 테스트에 비용이 많이 드는 것을 모킹하고 라이브러리와 프레임워크를 교체할 수 있다.(필요한 경우에) 원칙 # 클라이언트에 클린 아키텍처를 그대로 따라할 필요는 없지만, 클린 아키텍처의 디자인 원칙과 관행을 보고 이를 클라이언트에 적용하는 것은 좋은 생각이라고 본다. 각 원칙은 어떤 식으로든 수행할 수 있는 작업과 작업 구성 방식에 대한 구조적 제약을 적용하는 것이다. 명령 쿼리 분리 # commands - 상태를 변경하지만 데이터를 반환하지 않음. function createUser (props: UserDetails): Promise\u0026lt;void\u0026gt; { ... } function selectTodo (todoId: number): void { ... } queries - 데이터를 반환하지만 상태를 변경하지 않음 function getCurrentUser (): Promise\u0026lt;User\u0026gt; { ... } function getUserById (userId: UserId): Promise\u0026lt;User\u0026gt; { ... } 이 패턴의 주요 이점은 코드를 보다 쉽게 추론할 수 있다. 하나는 읽기용이고 하나는 쓰기용이다. 관심사 분리 # 클라이언트에서 위와 같이 관심사를 분리할 수 있다.\n기능은 수직 슬라이스다.\n기능 = 모듈? 레이어 # Presentation Components # 화면 구성요소는 UI 렌더링 및 사용자 이벤트를 생성한다. 화면 구성요소는 구현 세부사항이다. 화면 구성요소를 테스트할 때는 주로 UI 로직에 대해 테스트한다. UI Logic # 어떤 상황에 어떤 화면을 보여줘야 하는지, 사용자 이벤트에 대한 호출 시기를 결정하는 조건등이 UI논리이다. UI 로직은 실제로 컴포넌트 내에서 테스트하려고 하는 것이다. (통합테스트) 컨테이너 / 컨트롤러 # 전통적으로 컨테이너 컴포넌트의 책임은 다음과 같다. 사용자 이벤트를 소비하고 모델에 전달 데이터 변경 사항을 구독하고 보기를 업데이트된 상태로 유지 반응형 모델에 연결하는 방법과 프레젠테이션 구성 요소에서 발생하는 이벤트를 처리하는 방법을 아는데 책임이 있다. 인터렉션 레이어 # 의사 결정 계층이다. api 요청을 할 때 백엔드로 통신하기 전 이 요청을 보낼지 결정할 수 있다. 클린아키텍처에서 애플리케이션 레이어로 보면 된다. 리액트 훅이 아닌 다른 방법으로도 모델을 구현할 수 있다. (xState, pojo-observer) 일반적으로 여러 레이어가 있다. (인증, 로깅, 구독, 렌더링 로직, 메타데이터 등) 네트워킹 및 데이터 가져오기 # 이 계층의 책임은 다음과 같다. 백엔드 서비스의 위치 파악 응답 공식화 응답 데이터 또는 오류 마샬링 비동기 상태 보고 상태 관리 및 저장 # 상태 관리 라이브러리에는 세가지 책임이 있다. 저장소 - 일반적으로 저장소/클라이언트 측 캐시 어딘가에서 전역 상태를 유지한다. 데이터 업데이트 중 - 캐시의 데이터를 변경한다. 반응성 - 뷰 레이어 프레젠테이션 구성 요소가 데이터를 구독하고 데이터가 변경되면 다시 렌더링 할 수 있는 방법을 제공한다. 거의 2년전 게시글인데 리액트 쿼리 사용하는 현재 시점에선 위 아키텍처랑 비슷하게 개발하고 있는 것 같다. 애플리케이션 레이어에서 리액트 훅 없이 모델을 구현하는 방법이 궁금하다.\n","date":"2022 / 04 / 24","permalink":"/posts/study/etc/client-architecture/","section":"Posts","summary":"클라이언트 측 아키텍처 기본 요약","title":"클라이언트 측 아키텍처 기본 요약"},{"content":"의도를 분명히 밝혀라 # 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. 이름을 주의깊게 살펴 더 나은 이름으로 개선한다면 코드를 읽는 사람이 좀 더 행복해지리라. 변수, 함수, 클래스 이름은 다음과 같은 굵직한 질문에 모두 답해야 한다. 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. 코드 맥락이 코드 자체에 명시적으로 드러나야 한다. 단순히 이름만 고쳐도 함수가 하는 일을 이해하기 쉬워진다. 그릇된 정보를 피하라 # 프로그래머는 코드에 그릇된 단서를 남겨서는 안 된다. 예를들어 직각삼각형의 빗변으로 표현할 때 ‘hp’는 훌륭한 약어로 보일지라도 독자에게 그릇된 정보를 제공한다. (유닉스 변종을 가리키는 이름이기 때문에 헷갈릴 수 있다.) 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 accountList라 명명하지 마라. 프로그래머에게 List는 특수한 의미이다. 실제 List가 아니라면 프로그래머에게 그릇된 정보를 제공한 셈이다. accountGroup, bunchOfAccounts나 단순히 Accounts라 명명하는게 낫다. 서로 흡사한 이름을 사용하지 않도록 주의하라. 유사한 개념은 유사한 표기법을 사용해야 한다. 일관성이 떨어지는 표기법은 그릇된 정보다. IDE의 자동완성 기능은 주석까지 노출해주지 않는다. 의미 있게 구분하라 # 컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다. 컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 불용어(noise word)를 추가하는 방식은 적절하지 못하다. 이름이 달라야 한다면 의미도 달라져야 한다. 연속적인 숫자를 덧붙인 이름(a1, a2, a3\u0026hellip;)는 아무런 정보를 제공하지 못한다. 저자의 의도도 드러나지 않는다. Info나 Data와 같은 단어는 a, an, the와 마찬가지로 의미가 불분명한 불용어이다. ProductInfo, ProductData 이 두 이름은 개념을 구분하지 않은 채 이름만 달리한 경우다. 아무런 정보를 제공하지 못한다. 명확한 관례가 없다면 money와 moneyAmount는 구분이 안 된다. 읽는사람이 차이를 알도록 이름을 짓자. 발음하기 쉬운 이름을 사용하라 # 발음하기 어려운 이름은 토론하기 어렵다. 검색하기 쉬운 이름을 사용하라 # 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다는 문제점이 있다. ‘MAX_CLASSES_PER_STUDENT’는 검색으로 찾기 쉽지만, 숫자 7은 어렵다. e라는 문자도 변수 이름으로 적합하지 못하다. 대부분의 프로그램의 모든 문장에서 등장한다. 이런 관점에서 긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다. 인코딩을 피하라 # 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 아주 많다. 유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다. 요즘 나오는 프로그래밍 언어는 많은 타입을 지원하고, IDE에서는 코드를 컴파일 하지 않고도 타입오류를 감지할 정도로 발전했다. 이제는 헝가리식 표기법이나 기타 이름에 타입을 표기하는 방식은 오히려 방해가 될 뿐이다. 인터페이스 클래스와 구현 클래스 개인적으로 밥아저씨는 인터페이스 이름은 접두어를 붙이지 않는 편이 좋다고 생각한다. 다루고 있는 클래스가 인터페이스라는 사실을 남에게 알리고 싶지 않다. 클래스의 사용자는 그냥 ShapeFactory라고만 생각하면 좋겠다. 인터페이스 클래스 이름과 구현 클래스 이름 중 하나를 인코디해야 한다면 구현 클래스 이름을 택하겠다. (ShapeFactoryImp가 IShapeFactory 보다 낫다) 자신의 기억력을 자랑하지 마라 # 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면, 그 변수 이름은 바람직하지 못하다. 일반적으로 문제 영역이나 해법 영역에서 사용하지 않는 이름을 선택했기 때문에 생기는 문제다. 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다. 전문가 프로그래머는 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다. 클래스 이름 # 클래스 이름과 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account, AddressParser 등 Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 말자. 메서드 이름 # 메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등 접근자, 변경자, 조건자는 표준에 따라 값 앞에 get, set, is를 붙인다. 기발한 이름은 피하라 # 이름이 너무 기발하면 저자와 유머 감각이 비슷한 사람만, 그리고 농담을 기억하는 동안만 이름을 기억한다. 특정 문화에서만 사용하는 농담은 피하는 편이 좋다. 의도를 분명하고 솔직핟게 표현하라 한 개념에 한 단어를 사용하라 # 추상적인 개념 하나에 단어 하나를 선택해 이를 고수하자. 같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. 메서드 이름은 독자적이고 일관적이어야 주석을 뒤져보지 않고도 프로그래머가 올바른 메서드를 선택할 수 있다. 말장난을 하지마라 # 한 단어를 두 가지 목적으로 사용하지 마라. 때로는 프로그래머가 같은 맥락이 아닌데도 ‘일관성\u0026rsquo;을 고려해 한 단어로 두 가지 역할을 수행하도록 한다. 여러 클래스에서 add라는 메서드를 ‘숫자를 더함’의 의미로 사용하고 있는 상황에서 ‘집합에 값을 추가\u0026rsquo;하는 메서드를 만들 때는 ‘insert’, ‘append’와 같은 이름을 사용해야 한다. 일관성을 위해 다른 목적의 메서드를 같은 이름인 add로 부른다면 이는 말장난이다. 프로그래머는 코드를 최대한 이해하기 쉽게 짜야 한다. 집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표다. 의미를 해독할 책임이 독자에게 있는 논문 모델이 아니라 의도를 밝힐 책임이 저자에게 있는 잡지 모델이 바람직하다. 해법 영역 가져온 이름을 사용하라 # 코드를 읽을 사람도 프로그래머이므로 전산용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다. 모든 이름을 문제 영역(도메인)에서 가져오는 정책은 현명하지 못하다. 문제 영역에서 가져온 이름을 사용하라 # 적절한 프로그래머 용어가 없다면 문제 영역(도메인)에서 이름을 가져온다. 그러면 코드를 보수하는 프로그래머가 분야 전문가에게 의미를 물어 파악할 수 있다. 우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야 한다. 의미 있는 맥락을 추가하라 # 스스로 의미가 분명한 이름이면 좋지만, 대다수 이름은 그렇지 못하다.\n그래서 클래스, 함수, 이름 공간에 넣어 맥락을 부여한다.\nstate라는 이름만 보고 주소라고 유추하기 어렵다. addr 접두어를 추가해서 addrState라 쓰면 맥락이 좀 더 분명해진다. 함수 예시\nfunction printGuessStatistics(candidate: string, count: number) { let number: string, verb: string, pluralModifier: string; if (count === 0) { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } else if (count === 1) { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } else { number = count.toString(); verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } console.log(`There ${verb} ${number} ${candidate}${pluralModifier}`); } 이 함수의 이름은 맥락의 일부만 제공하며, 알고리즘이 나머지 맥락을 제공한다. 함수를 끝까지 읽어보고 나서야 number, verb, pluralModifier라는 변수 세 개가 ‘통계 추측\u0026rsquo; 메시지에 사용된다는 사실이 드러난다. 맥락을 유추하는건 독자의 몫이 된다. 그냥 메서드만 훑어서는 세 변수의 의미가 불분명하다.\nclass GuessStatisticsMessage { number: string; verb: string; pluralModifier: string; make(candidate: string, count: number) { this.createPluralDependentMessageParts(count); console.log(`There ${this.verb} ${this.number} ${candidate}${this.pluralModifier}`); } createPluralDependentMessageParts(count: number) { if (count === 0) { this.thereAreNoLetters(); } else if (count === 1) { this.thereIsOneLetter(); } else { this.thereAreManyLetters(count); } } thereAreNoLetters() { this.number = \u0026#34;no\u0026#34;; this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } thereIsOneLetter() { this.number = \u0026#34;1\u0026#34;; this.verb = \u0026#34;is\u0026#34;; this.pluralModifier = \u0026#34;\u0026#34;; } thereAreManyLetters(count: number) { this.number = count.toString(); this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } } 위와 같이 GuessStatisticsMesssage라는 클래스를 만든 후 세 변수를 클래스에 넣으니 변수의 맥락이 분명해졌다. 이렇게 맥락을 개선하면 함수를 쪼개기 쉬워지고 알고리즘도 더 명확해진다.\n불필요한 맥락을 없애라 # ‘고급 휘발유 충전소(Gas Station Deluxe)’라는 애플리케이션을 짤 때 모든 클래스의 이름을 GSD로 시작하겠다는 생각은 바람직 하지 못하다. 일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서만. 그러므로 이름에 불필요한 맥락을 추가하지말자. accountAddress, customerAddress는 Address 클래스 인스턴스로는 좋은 이름이나 클래스 이름으로는 적합하지 못하다. 마치면서 # 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다. 좋은 이름을 선택하는 능력은 기술, 비즈니스, 관리 문제가 아니라 교육 문제다. 우리 분야 사람들이 이름 짓는 방법을 제대로 익히지 못하는 이유는 이 때문이다. 사람들이 이름을 바꾸지 않으려는 이유 하나는 다른 개발자가 반대할까 두려워서다. 우리들 대다수는 자신이 짠 클래스 이름과 메서드 이름을 모두 암기하지 못한다. 암기는 요즘 나오는 도구에게 맡기고, 우리는 문장이나 문단처럼 읽히는 코드 아니면 적어도 표나 자료 구조처럼 읽히는 코드를 짜는데만 집중해야 마땅하다. 여느 코드 개선 노력과 마찬가지로, 이름 역시 나름대로 바꿨다가 누군가의 질책을 받을 지 모르지만 그렇다고 코드를 개선하려는 노력을 중단해서는 안된다. ","date":"2022 / 04 / 24","permalink":"/posts/study/clean-code/02-naming/","section":"Posts","summary":"클린코드 2장 의미있는 이름 요약","title":"클린코드 2장 의미있는 이름 요약"},{"content":"이 책은 좋은 프로그램 작성 요령을 설명하는 책이다. 코드에 대한 많은 사실, 좋은 코드와 나쁜 코드를 구분하는 능력, 나쁜 코드를 좋은 코드로 바꾸는 실력을 배울 수 있다.\n코드가 존재하리라 # 코드는 자동으로 생성하는 시대가 오면 프로그래머는 필요가 없어질까? 아니다. 앞으로도 코드가 사라질 가능성은 없다. 코드는 요구사항을 상세히 표현하는 수단이다. 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 이것이 프로그래밍이다. 우리가 시키는 대로가 아니라 원하는 대로 돌아가는 기계가 나오는 것은 불가능하다. 요구사항을 모호하게 줘도 우리 의도를 정확히 꿰뚫어보는 프로그램 말이다. 창의력과 직관을 보유한 인간조차 고객의 막연한 감정만 갖고는 성공적인 시스템을 구현하지 못한다. 프로그래밍 언어에서 추상화 수준은 점차 높아지겠지만, 코드가 사라지진 않을 것이다, 나쁜 코드 # 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 나중은 결코 돌아오지 않는다. 나쁜 코드로 치르는 대가 # 나쁜 코드는 개발 속도를 크게 떨어뜨린다. 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다. 우리는 나쁜 코드가 작성한 것에 대해 온갖 이유를 들이댄다. (요구사항 변경, 시간 독촉 등) 하지만 이는 우리의 잘못이다. 시간을 독촉하는 관리자는 그것이 그들의 책임이기 때문에 한 것이다. 좋은 코드를 사수하는 일은 프로그래머의 책임이다. 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다. 시간이 없다고 나쁜 코드를 양산하면 오히려 더 늦어진다. 빨리가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. 깨끗한 코드라는 예술? # 깨끗한 코드를 작성하려면 \u0026lsquo;청결\u0026rsquo;이라는 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다. 열쇠는 \u0026lsquo;코드 감각\u0026rsquo;이다. 타고날 수도 있고, 노력으로 얻을 수 있다. \u0026lsquo;코드 감각\u0026rsquo;이 있으면 좋은 코드와 나쁜 코드를 구분할 뿐만 아니라, 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다. \u0026lsquo;코드 감각\u0026rsquo;이 없는 프로그래머도 때로는 나쁜 모듈을 알아보지만 그것으로 끝이다. 코드 감각\u0026rsquo;이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. 깨끗한 코드란? # 유명한 프로그래머에게 의견을 물었다. 비야네 스트롭스트룹 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. 프로그래머들이 대충 넘어가는 부분 중 하나가 오류처리다. 깨끗한 코드를 위해 세세한 사항까지 꼼꼼히 처리하자. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다. 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다. 창문이 깨진 건물은 누구도 상관하지 않는다는 인상을 품긴다. 그래서 사람들도 관심을 끊는다. 창문이 더 깨져도 상관하지 않는다. 마침내 자발적으로 창문을 깨고 외벽에 낙서를 방치하고 차고에 쓰레기가 쌓여도 치우지 않는다. 창문이 깨지고 나면 쇠퇴하는 과정이 시작된다. 그래디 부치 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다. 데이브 토마스 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. api는 명확하며 최소로 줄였다. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다. 마이클 페더스 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 론 제프리스 모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수등을 최대한 줄인다. 워드 커닝햄 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 부를 수 있다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 된다. 프로그램을 단순하게 모이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다. 밥아저씨의 생각 # 이 책은 밥 아저씨와 동료들이 정의한 깨끗한 코드를 상세히 설명한다. 사람마다 클린 코드에 대한 정의는 다르므로, 이 책에서 정의하는 클린코드가 진리이고 다른 코드가 틀린것은 아니다. 보이스카우트 규칙 # 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 시간이 지나면서 엉망으로 전락하는 코드가 한둘이 아니다. 캠프장을 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라. 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다. 결론 # 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다. ","date":"2022 / 04 / 23","permalink":"/posts/study/clean-code/01-clean-code/","section":"Posts","summary":"클린코드 1장 깨끗한 코드 요약","title":"클린코드 1장 깨끗한 코드 요약"},{"content":"hugo + congo 테마로 블로그 개설했습니다.\n이전에도 기술 블로그를 꾸준하게 운영하긴 했습니다. 이전 블로그인 노션 블로그는 seo 검색 노출이 잘 안되고, 티스토리는 맘에 드는 테마가 없었고, hashnode는 좀 느리고 등등 이런 저런 이유로 한 플랫폼에 정착하지 못하고 계속 옮겨다녔습니다. 이전에 작성했던 기록들이 버려지는게 아쉽네요.\n이번 블로그는 디자인도 맘에들어서 seo 노출만 잘 된다면 꾸준하게 오래오래 운영해보겠습니다 :)\nreference # 이전 블로그\ncongo 테마\n","date":"2022 / 04 / 15","permalink":"/posts/hello/","section":"Posts","summary":"soso01 개발 블로그 생성","title":"블로그 개설"}]