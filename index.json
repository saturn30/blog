[{"content":"01. 데이터 중심의 영화 예매 시스템 # 가끔 나쁜 설계를 살펴보는 과정에서 통찰을 얻기도 한다. 이번 장에서는 데이터(상태) 중심의 관점에서 영화 예매 시스템을 설계해본다. 02. 설계 트레이드오프 # 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화의 응집도, 결합도를 사용한다. 본격적으로 두 방법을 비교하기 전에 세 가지 품질 척도의 의미를 살펴보자. 캡슐화 # 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 구현이란 나중에 변경될 가능성이 높은 어떤 것 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다. 객체를 사용해 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다. 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다. 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다. 객체지향의 가장 중요한 원리가 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다. 캡슐화로 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있다. 응집도와 결합도 # 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.\n모듈내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다. 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가짐. 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.\n어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다. 반면 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다. 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.\n좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.\n하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈 일부만 변경된다면 응집도가 낮은 것이다. 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 위해 코드 구석구석을 헤매고 다니거나 여러 모듈을 동시에 수정할 필요 없이 한 모듈만 수정하면 된다. 결합도는 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.\n결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기 어려워진다. 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다.\n인터페이스에 대해 프로그래밍하라 일반적으로 변경될 확률이 매우 적은 안정적인 모듈에는 의존하여 결합도가 높아도 상관없다. (표준 라이브러리 등)\n하지만 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높다. 03. 데이터 중심의 영화 예매 시스템의 문제점 # 데이터 중심의 설계는 캡슐화를 위반하고 객체 내부 구현을 인터페이스의 일부로 만든다. 반면 책임 중심 서례는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화한다. 캡슐화의 정도가 객체의 응집도와 결합도를 결정한다. 데이터 중심 설계의 대표적인 문제 캡슐화 위반 높은 결합도 낮은 응집도 캡슐화 위반 # class Movie { private Money fee; getFee = () =\u0026gt; this.fee; setFee = () =\u0026gt; this.fee; } 데이터 중심으로 설계한 예시 코드는 오직 메서드를 통해서만 객체의 내부 상태에 접근한다. 위 코드는 직접 내부에 접근할 수 없기 때문에 캡슐화 원칙을 지키는 것 처럼 보이지만, 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다. get, set 메서드는 Movie 내부에 fee라는 이름의 변수가 존재한다는 사실을 퍼블릭 인스턴스에 노골적으로 드러낸다. 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다. 객체가 사용될 문맥을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것이다. 앨런 홀럽은 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라고 부른다. 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다. 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수밖에 없다. 높은 결합도 # 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다. 단지 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다. 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다. 이 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수 밖에 없다. 데이터 중심 설계는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다. 낮은 응집도 # 낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다. 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. 응집도가 낮을 경우 다른 모듈에 위치해야할 책임의 일부가 엉뚱한 곳에 위치하게 되기 때문이다. 04. 자율적인 객체를 향해 # 캡슐화를 지켜라 # 캡슐화는 설계의 제 1원리다. 데이터 중심 설계가 낮은 응집도와 결합도로 박살난 원인은 바로 캡슐화를 위반했기 때문 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다. 여기서 말하는 메서드는 단순히 속성 하나의 값을 반환하거나 변경하는 접근자나 수정자를 의미하는 것은 아니다. 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다. class Rectangle { private left: number; private top: number; private right: number; private bottom: number; public getLeft() ... } 위 코드에서 사각형의 너비와 높이를 증가시키는 코드가 필요하다고 가정하자. 이 클래스를 사용하는 클라이언트 측에서 set함수를 이용해 너비와 높이를 변경하는 구현을 직접 해야 한다. 이는 코드 중복을 발생시킬 확률이 높으며 변경에 취약하다. 만약 right와 bottom 대신 length, height를 이용해서 사각형을 표현한다면? 호출부의 모든 코드를 수정해야 한다. class Rectangle { enlarge = (multiple: number) =\u0026gt; { right *= multiple; bottom *= multiple; }; } 위와같이 Rectangle 내부에서 너비와 높이를 조절하는 로직을 캡슐화 하면 두가지 문제를 해결할 수 있다. 스스로 자신의 데이터를 책임지는 객체 # 우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 객체는 단순한 데이터 제공자가 아니다. 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 중요하다. 객체를 설계할 때 ‘이 객체가 어떤 데이터를 포함해야 하는가?’라는 질문은 다음 두 개의 개발적인 질문으로 쪼개져야한다. 이 객체가 어떤 데이터를 포함해야 하는가? 이 객체가 데이터에 대해 수행해야 하는 오퍼레이터는 무엇인가? 05. 하지만 여전히 부족하다 # 06. 데이터 중심 설계의 문제점 # 캡슐화를 위반한 설계는 변경에 취약하다. 데이터 중심의 설계가 변경에 취약한 이유 두 가지 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다. # 데이터 중심 설계를 시작할 때 던지는 첫 번째 질문은 “이 객체가 포함해야 하는 데이터가 무엇인가?” 이다. 데이터는 구현의 일부이다. 데이터 주도 설계는 설계를 시작하는 처음부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 된다. 데이터 중심 설계 방식에 익숙한 개발자들은 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다. 이것은 상태와 행동을 하나의 단위로 캡슐화하는 객체지향 패러다임에 반한다. 이로 인해 접근자와 수정자를 과도하게 추가하게 되고 이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현하게 된다. 접근자와 수정자는 public 속성과 큰 차이가 없기 때문에 객체의 캡슐화는 완전히 무너질 수 밖에 없다. 비록 데이터를 처리하는 작업과 데이터를 같은 객체 안에 두더라도 데이터에 초점이 맞춰져 있다면 만족스러운 캡슐화를 얻기 어렵다. 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. 결과적으로 객체의 인터페이스는 구현을 캡슐화하는데 실패하고 변경은 취약해진다. 결론적으로 데이터 중심 설계는 너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다. 객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경에 취약한 코드를 낳게 된다. 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다 # 올바른 객체지향 설계의 무게 중심은 하상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다. 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 실행 문맥에 대한 깊이있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없다. 객체의 인터페이스에 구현이 노출돼 있었기 때문에 협력이 구현 세부사항에 종속돼 있고 그에 따라 객체의 내부 구현이 변경됐을 때 협력하는 객체 모두가 영향을 받는다. ","date":"2022 / 07 / 02","permalink":"/posts/study/object/object-04/","section":"Posts","summary":"오브젝트 4장 설계품질과 트레이드오프","title":"오브젝트 4장 설계품질과 트레이드오프"},{"content":" 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 객체지향에서 가장 중요한 것은 역할, 책임, 협력이다. 01. 협력 # 협력 : 객체들이 앱의 기능을 구현하기 위해 수행하는 상호작용 책임 : 객체가 협력에 참여하기 위해 수행하는 로직 역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 수행하는 것 협력 # 객체지향 시스템은 자율적인 객체들의 공동체이다. 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적 존재이다. 협력은 기능을 구현할 수 있는 유일한 방법이다. 메시지 전송으로부터 협력이 시작된다. 메시지를 수신한 객체는 메서드를 실행해 요청에 응답한다. 객체가 메시지를 처리할 방법은 스스로 선택한다는 점이 중요 → 자율성 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기 쉬워진다. 협력이 설계를 위한 문맥을 결정한다. # 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다. 협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다. 객체의 행동을 결정하는 것이 협력이라면, 객체의 상태를 결정하는 것은 행동이다. 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다. 상태는 객체가 행동하는데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥을 제공한다. 02. 책임 # 책임이란 무엇인가 # 협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다. 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다. 객체의 책임은 무엇을 알고 있는가?(하는 것)와, 무엇을 할 수 있는가? (아는 것) 로 구성된다. 하는 것 객체를 생성하거나 계산을 수행하는 등 스스로 하는 것 다른 객체의 행동을 시작시키는 것 다른 객체의 활동을 제어하고 조절하는 것 아는 것 사적인 정보에 관해 아는 것 관련된 객체에 관해 아는 것 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 협력안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다. 책임과 메시지의 크기는 다르다. 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 더 크다. 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것이다. 적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야만 단순하고 유연한 설계를 창조할 수 있다. 객체에게 얼마나 적절한 책임을 할당하느냐가 설게의 전체적인 품질을 결정한다. 책임 할당 # 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다. 객체들 역시 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다. 요청에 응답하기 위해 필요한 행동이 객체가 수행할 책임으로 이어진다. 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의한다. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다. 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이뤄진다. 이렇게 결정된 메시지는 객체의 퍼블릭 인터페이스를 구성한다. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션 목록을 얻게 된다. 책임 주도 설계 # 협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다. 어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정한다. 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임주도 설계라고 부른다. 설계 과정 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. 시스템 책임을 더 작은 책임으로 분할한다. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 메시지가 객체를 결정한다. # 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택했다는 것이 중요하다. 메시지가 객체를 선택하게 해야 하는 이유 최소한의 인터페이스를 가질 수 있게 된다. 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 앱에 크지도, 작지도 않은 꼭 필요한 크기의 인터페이스를 가질 수 있다. 충분히 추상적인 인터페이스를 가질 수 있게 된다. 객체의 인터페이스는 무엇을 하는지는 표현해야 하지만 어떻게 수행하는지는 노출해선 안된다. 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 촞머을 맞추는 인터페이스를 얻을 수 있다. 행동이 상태를 결정한다. # 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다. 객체는 협력에 필요한 행동을 제공해야 한다. 객체를 객체답게 만드는 것은 상태가 아니라 행동이다. 객체지향을 갓 입문한 사람이 가장 쉽게 빠지는 실수가 객체의 행동이 아니라 상태에 초점을 맞추는 것이다. 필요한 상태가 무엇인지 먼저 결정하면 객체의 내부 구현이 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다. 03. 역할 # 역할과 협력 # 객체는 협력이라는 문맥 안에서 특정한 목적을 갖게 된다. 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다. 책임의 집합 ⇒ 역할 유연학 재사용 가능한 협력 # 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다. 메시지를 수신할 수 있는 객체가 여러개라면, 그들의 대표자를 역할이라는 개념으로 추상화할 수 있음. 2장 예제의 AmountDiscountPolicy, PercentDiscountPolicy 각각의 객체를 추상클래스인 DiscountPolicy로 포괄해서 생각할 수 있음. 역할을 이용하면 불필요한 중복 코드를 제거할 수 있으며, 협력이 더 유연해진다. 어떤 객체라도 동일한 역할을 수행한다면 협력에 참여할 수 있게 된다. 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다. 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 이용하는 것임. 객체 대 역할 # 역할은 객체가 참여할 수 있는 일종의 슬롯이다. 따라서 유용하고 재사용 가능한 설계라는 문맥에서 역할은 중요함. 만약 한 종류의 객체만이 협력에 참여한다면? 굳이 역할로 추상화 하지 않고 객체로 바라봐도 된다. 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고, 역할과 객체를 명확하게 구분짓는 것은 그렇게 중요하진 않다. 구분하기 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법이다. 역할과 추상화 # 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다. 역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 것이다. 추상화의 장점 세부 사항에 억눌리지 않고도 상위 수준의 정책을 쉽고 간단하게 표현할 수 있다. 협력이라는 관점에서 세부적인 사항을 무시하고 추상화에 집중하는 것이 유용하다. 설계를 유연하게 만든다. 협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에 서로 대체 가능하다. 따라서 역할은 다양한 환경에서 다양한 객체들을 수용하게 해주므로 협력을 유연하게 만든다. ","date":"2022 / 06 / 30","permalink":"/posts/study/object/object-03/","section":"Posts","summary":"오브젝트 3장 역할, 책임, 협력","title":"오브젝트 3장 역할, 책임, 협력"},{"content":"01. 영화 예매 시스템 # 영화 / 상영 할인 할인 조건 - 할인이 가능한지 할인 정책 - 적용되는 비용 02. 객체지향 프로그래밍을 향해 # 협력, 객체, 클래스 # 대부분의 사람은 클래스를 결정한 후 클래스에 어떤 속성과 메서드가 필요한지 고민한다. 이는 객체지향의 본질과는 거리가 멀다. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다. 객체를 중심에 두는 접근방법은 설계를 단순하고 깔끔하게 만든다. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라 객체는 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다. 객체를 협력 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다. 객체 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라 도메인의 구조를 따르는 프로그램 구조 # 도메인 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다. 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 객체와 클래스로 매끄럽게 연결될 수 있다. 클래스 구현하기 # https://github.com/soso01/object/tree/main/chapter2\n클래스를 구현하거나 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정하는 것 구분해야 하는 이유는? 경계의 명확성이 객체의 자율성을 보장한다. 프로그래머에게 구현의 자유를 제공한다. 자율적인 객체 # 중요한 두가지 사실 객체는 상태와 행동을 함께 가지는 복합적인 존재임 객체는 스스로 판단하고 행동하는 자율적인 존재 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다. 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다. 객체지향 언어들은 캡슐화에서 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어 메커니즘도 함께 제공한다. private, protected, public … - 접근 수정자 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서이다. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다. 외부에서는 객체에게 원하는 것을 요청하고 객체가 스스로 최선의 방법을 결정할 수 있을 것이라는 점을 믿고 기다려야 한다. 캡슐화와 접근 제어는 두 부분으로 나뉜다. 퍼블릭 인터페이스 - 외부에서 접근 가능한 부분 구현 - 내부에서만 접근가능한 부분 인터페이스와 구현의 분리는 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다. 프로그래머의 자유 # 프로그래머의 역할을 클래스 작성자와, 클라이언트 프로그래머로 구분하자. 클래스 작성자는 새로운 타입을 프로그램에 추가한다. 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다. 접근제어를 통해 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다. 이를 구현은닉이라고 부른다. 구현은닉은 클라이언트 프로그래머에게도 유용하다. 클라이언트 프로그래머는 내부의 구현을 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다. 설계가 필요한 이유는 변경을 관리하기 위해서다. 객체의 변경을 관리할 수 있는 가장 대표적인 것이 접근 제어다. 변경될 가능성이 있는 세부적인 구현 내용을 private 영역에 감춤으로써 변경으로 인한 혼란을 최소화 할 수 있다. 협력하는 객체들의 공동체 # 가격에 대한 타입을 number 대신 Money라는 새 객체로 정의하는 것은 유용하다. number타입은 Money타입처럼 저장하는 값이 금액과 관련되어 있다는 의미를 전달할 수 없다. 또한 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없다. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있는 것이다. 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라. 협력에 대한 짧은 이야기 # 객체는 외부에 공개되어있는 퍼블릭 인터페이스를 통해 내부 상태에 접근하도록 허용한다. 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있고, 요청 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것이다. 다른 객체에 요청이 도착할 때 해당 객체가 메시지를 수신한다. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라 부른다. 메시지와 메서드를 구분하는 것은 매우 중요하다. 이 구분은 객체지향 패러다임이 유연하고 확장가능하며, 재사용 가능한 설계를 할 수 있도록 크게 기여함. 메시지와 메서드의 구분에서부터 다형성의 개념이 출발한다. 03. 할인 요금 구하기 # https://github.com/soso01/object/tree/main/chapter2\n04. 상속과 다형성 # 컴파일 시간 의존성과 실행 시간 의존성 # 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 다시 말해, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다. 쉽게 재사용할 수 있으며, 확 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다. 예제에서 코드상 Movie는 DiscountPolicy라는 추상클래스에 의존성을 갖지만, 실행 시점에서의 의존성의 DiscountPolicy의 상속클래스인 AmountDiscountPolicy에 의존한다. 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다. 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물임을 보여준다. 설계를가 유연해지면 코드를 이해하고 디버깅하기 점점 더 어려워지고, 유연성을 억제하면 코드를 이해하기 쉽지만, 재사용성과 확장 가능성은 낮아진다. 차이에 의한 프로그래밍 # 상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다. 부모 클래스의 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라고 부른다. 상속과 인터페이스 # 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 자식클래스는 부모 클래스의 인터페이스를 포함하므로, 결과적으로 부모클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다. 외부 클래스의 입장에선 객체가 어떤 클래스의 인스턴스인지 중요하지 않다. 메시지를 수신할 수 있으면 무엇이든 상관없음. 다형성 # 다형성 - 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다. 상속을 이용하면 동일한 인터페이스를 공유하는 클래스들을 하나의 타입 계층으로 묶을 수 있다. 05. 추상화와 유연성 # 추상화의 힘 # 추상화를 사용할 경우의 두 가지 장점 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다. 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 한다. 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 설계가 좀 더 유연해진다. 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다. 유연한 설계 # export class Movie { ... calculateMovieFee = (screening: Screening) =\u0026gt; { if (this.discountPolicy === null) return this.fee; return this.fee.minus( this.discountPolicy.calculateDiscountAmount(screening) ); }; } 위 방식의 문제점은 할인 정책이 없는 경우를 예외 케이스로 취급하기 때문에 지금까지 일관성 있었던 협력방식이 무너진다. 할인 금액을 결정하는 책임이 DiscountPolicy가 아닌, Movie쪽에 있다. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다. 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라. export class NoneDiscountPolicy extends DiscountPolicy { protected override getDiscountAmount = () =\u0026gt; Money.ZERO; } 위와 같이 새 클래스를 추가해서 일관성을 지킬 수 있다. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결함되는 것을 방지하기 때문이다. 코드 재사용 # 코드 재사용을 위해서는 상속보다 합성이 더 좋은 방법이다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다. 상속 # 두가지 관점에서 상속은 설계에 좋지 않다. 캡슐화를 위반함 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 결과적으로 부모의 구현이 자식에 노출되기 때문에 캡슐화가 약해진다. 캡슐화의 약화는 자식과 부모를 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식도 함게 변경될 확률을 높인다. 설계를 유연하지 못하게 만듦 상속은 부모와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 바꾸는 것이 불가능하다. 합성 # 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이 합성이다. 합성은 상속이 가지는 두가지 문제를 모두 해결한다. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다. 그렇다고 상속을 쓰면 안되는 것은 아님. 대부분의 설계에서 상속과 합성을 같이 사용한다. ","date":"2022 / 06 / 26","permalink":"/posts/study/object/object-02/","section":"Posts","summary":"오브젝트 2장 객체지향 프로그래밍","title":"오브젝트 2장 객체지향 프로그래밍"},{"content":"서론 # 실무가 이론보다 먼저다. 실무를 하면서 관찰한 결과를 바탕으로 이론이 정립된다. 소프트웨어 분야는 아직 걸음마 단계에 머물러 있기 때문에 이론보다 실무가 더 앞서있음. 소프트웨어 유지보수의 경우 그 격차가 더 심하다. 실무에서는 다양한 규모의 소프트웨어를 유지보수하고 있지만, 소프트웨어 유지보수에 관련된 효과적인 이론은 발표되지 않았다. 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적이다. 추상적인 개념과 이론은 훌륭한 코드를 작성하는데 필요한 도구일 뿐이다. 01. 티켓 판매 애플리케이션 구현 # https://github.com/soso01/object/tree/main/chapter1/1-1\n02. 무엇이 문제인가? # 로버트 마틴의 소프트웨어 모듈이 가져야 하는 세 가지 기능 실행 중에 제대로 동작하는 것 변경이 용이 할 것 이해하기 쉬울 것 1-1 챕터의 코드는 제대로 동작하지만, 변경 용이성과 읽는 사람과의 의사소통이라는 목적을 만족시키지 못함. 예상을 빗나가는 코드 # 관람객과 판매원이 극장의 통제를 받는 수동적인 존재이다. 티켓을 꺼내 관람객의 가방에 집어넣고, 관람객에게 받은 돈을 매표소에 적립하는 행동을 극장이 수행한다. 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다. 위의 예시는 일반 상식과 다르게 동작하기 때문에 코드를 읽는 사람과 제대로 소통하지 못함. 극장에 모든 세부적인 내용이 한번에 들어가기 때문에 판매원, 관람객의 세부사항을 극장에서 알고 있어야 한다. 변경에 취약한 코드 # 의존성은 변경에 대한 영향을 암시한다. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포됨 객체 사이의 의존성이 과한 경우 결합도가 높다고 말한다. 두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다. 03. 설계 개선하기 # https://github.com/soso01/object/tree/main/chapter1/1-3\n코드를 이해하기 어려운 이유는 극장에서 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다. 의도를 정확하게 의사소통하지 못하기 때문에 코드가 이해하기 어려워진 것이다. 극장이 관람객과 판매원의 너무 세세한 부분까지 알지 못하도록 정보를 차단하자. 관람객과 판매원을 자율적인 존재로 만든다. 자율성을 높이자 # 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라 한다. 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다. 수정 사항 # 수정된 관람객과 판매원은 자신이 가지고 있는 소지품을 스스로 관리한다. 이는 우리의 예상과 일치하게 작동하는 코드다. 읽는 사람과의 의사소통이라는 관점에서 확실히 개선되었다. 관람객과 판매원의 내부 구현을 변경하더라도 극장의 코드를 함께 변경할 필요가 없어졌다. 객체의 자율성을 높이는 방향으로 설계를 개선하여, 이해하기 쉽고 유연한 설계를 얻을 수 있었다. 캡슐화와 응집도 # 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메세지를 통해서만 상호작용하도록 만드는 것이다. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다. 자신의데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다. 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다. 자신이 소유하고 있지 않은 데이터를 이용해 작업을 처리하는 객체에게 어떻게 연관성 높은 작업들을 할당할 수 있겠는가? 외부의 간섭을 최대한 배제하고 메세지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다. 절차지향과 객체지향 # 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.\n절차적 프로그래밍의 세상은 우리의 예상을 쉽게 벗어나기 때문에 코드를 읽는 사람과 원활하게 의사소통하지 못한다.\n절차적 프로그래밍의 세계에서 관람객과 판매원은 수동적인 존재 절차적 프로그래밍의 세상에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.\n따라서 변경하기 어려운 코드를 양산하는 경향이 있다. 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.\n절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수 밖에 없다. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 프로그래밍 방식을 객체지향 프로그래밍이라고 부른다.\n자신의 데이터를 스스로 처리하도록 극장의 프로세스를 판매원과 관람객으로 이동 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.\n책임의 이동 # 두 방식 사이에 근본적인 차이를 만드는 것은 책임의 이동이다. 여기서 책임은 기능을 가리키는 객체지향 세계의 용어로 생각해도 무방함. 절차지향 방식에서는 책임이 극장에 집중되어 있었음. 그에 반해 객체지향 설계에서는 제어 흐름이 각 객체에 적절하게 분산된다. 극장에 몰려있던 책임이 각 개별 객체로 이동한 것. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다. 객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다. 사실 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다. 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다. 객체가 어떤 데이터를 가지느냐 보다는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞추자 설계를 어렵게 만드는 것은 의존성이다. 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추자. 더 개선하기 # 관람객이 소지하고 있는 가방과, 판매원의 판매소 객체에 자율권을 가지도록 수정함. 자율권을 주기 위해 기존에 없었던 의존성이 생겨날 수 있다. 결합도와 자율성 모두를 만족시키는 방법이 없다면 트레이드 오프를 해야 한다. 이 예제로 알 수 있는 것 두가지 어떤 기능을 설계하는 방법은 한 가지 이상이다. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다. 그래, 거짓말이다 # 직관에 따르는 코드는 이해하기 더 쉽다. 하지만 이후에 수정한 가방과 판매소는 실세계에서 자율적인 존재가 아니므로 어색하게 느껴진다. 코드에서 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급한 것이다. 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다. - 의인화 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다. 그 대상이 비록 생명이 없는 수동적인 존재라고 생각하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다. 04. 객체지향 설계 # 설계가 왜 필요한가 # 설계란 코드를 배치하는 것이다. 어떤 사람들은 설계가 코드를 작성하는 것보다 높은 차원의 창조적인 행위라고 생각한다. 하지만 설계와 구현을 떨어뜨려서 이야기하는 것은 불가능하다. 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다. 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다. 좋은 설계란 무엇인가? 우리는 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 변경을 수용할 수 있는 설계가 중요한 또 다른 이유는 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다. 요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그가 발생할 가능성을 높인다. 버그의 가장 큰 문제점은 코드를 수정하려는 의지를 꺾는다. 객체지향 설계 # 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다. 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다. 변경 가능한 코드란 이해하기 쉬운 코드다. 객체지향 패러다임은 여러분이 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다. 단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니다. 객체지향의 세계에서 애플리케이션은 객체들로 구성되며 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현된다. 객체들 사이의 상호작용은 객체 사이에 주고 받는 메시지로 표현된다. 훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다. 객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다. 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다. 데이터와 프로세스를 하나의 덩어리로 모드는 것은 훌륭한 객체지향 설계로 가는 첫걸음일 뿐이다. 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다. ","date":"2022 / 06 / 25","permalink":"/posts/study/object/object-01/","section":"Posts","summary":"오브젝트 1장 객체, 설계 요약","title":"오브젝트 1장 객체, 설계 요약"},{"content":" nestjs 공부 목적으로 간단한 로그인 페이지를 만들었다.\nnestjs에 orm은 prisma로 postgres 썼고, 인증쪽은 passport-jwt 라이브러러리 사용했다.\n느낀점은 개념을 알고나니 생각보다 생산성이 좋다. express보다 코드량이 늘어나서 개발속도가 느려지지 않을까 생각했었다. 하지만 nest의 필터, 가드 등의 개념들은 어차피 express에서도 구현했어야 하는 부분들이고, 오히려 nest cli 로 리소스 생성하는게 편해서 express보다 만족도가 높았다. 구조가 정해져 있으니 고민할게 적은 점도 장점이다.\n프론트랑 백엔드 앱 두개를 같이 개발했는데 테스트를 짜는게 힘들다. 정확히는 백엔드에서 테스트코드를 작성하면서 api를 만들고 나서, 프론트 개발을 할때 어차피 서버에서 검증한 데이터라고 생각되어서 테스트를 짜는게 귀찮아진다. 그래서 위 레포에서는 프론트 테스트는 하나도 없다. 서버의 테스트와 중복되지 않는 의미있는 테스트만 작성하려면 어떻게 해야 할까\n링크 - https://github.com/soso01/nestjs-study\n","date":"2022 / 06 / 01","permalink":"/posts/dev/nest-auth/","section":"Posts","summary":"nestjs 회원가입, 인증","title":"nestjs 회원가입, 인증"},{"content":"클래스 체계 # 자바 표준 관례에 따른 순서 정적 공개 상수 \u0026gt; 정적 비공개 변수 \u0026gt; 비공개 인스턴스 변수 \u0026gt; 공개함수.. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다. 캡슐화 # 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다. 테스트를 위해 protected로 선언하는 경우도 있지만 캡슐화를 풀어주는 결정은 언제나 최후의 수단이어야 한다. 클래스는 작아야 한다! # 함수는 물리적인 행 수로 크기를 측정했지만, 클래스는 다르다. 클래스는 맡은 책임을 센다. 메서드 갯수가 작더라도 책임이 너무 많다면 좋지않다. 클래스 이름이 모호하다면 클래스의 책임이 너무 많아서다. 단일 책임 원칙 # 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다. 클래스는 책임, 즉 변경할 이유가 하나여야 한다는 의미다. 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. SRP는 클래스 설계자가 가장 무시하는 규칙 중 하나다. 소프트웨어를 돌아가게 만드는 활동과 깨끗하게 만드는 활동은 별개다. 우리들 대다수는 두뇌 용량에 한계가 있어 ‘깨끗하고 체계적인 소프트웨어\u0026rsquo;보다 ‘돌아가는 소프트웨어\u0026rsquo;에 초점을 맞춘다. 관심사를 분리하는 작업은 프로그램만이 아니라 프로그래밍 활동에서도 마찬가지로 중요하다. 문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. ‘깨끗하고 체계적인 소프트웨어’라는 다음 관심사로 전환하지 않는다. 게다가 많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 우려한다. 큰 그림을 이해하려면 이 클래스 저 클래스 수없이 넘나들어야 한다고 걱정한다. 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품의 수는 비슷하다. 어느 시스템이든 익힐 내용은 그 양이 비슷하다. 규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다. 이런 복잡성을 다루려면 체계적인 정리가 필수다. 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다. 응집도 # 클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. ‘함수를 작게, 매개변수 목록을 짧게\u0026rsquo;라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다. 응집도를 유지하면 작은 클래스 여럿이 나온다. # 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 큰 함수의 일부를 작은 함수로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다면? 그렇다면 변수 네 개를 새 함수에 인수로 넘겨야 옳을까? 아니다. 네 변수를 클래스 인스턴스 변수로 승격하면 새 함수는 인수가 필요없다. 불행히도 이렇게 하면 클래스가 응집력을 잃는다. 몇몇 함수만 사용하는 인스턴스 변수가 늘어나기 때문이다. 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리하면 되지 않을까? → 정답 클래스가 응집력을 잃는다면 쪼개라. 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 클래스를 쪼개고 리팩터링하면 길이는 늘어난다. 그 이유는, 리팩토링한 프로그램은 더 길고 서술적인 변수 이름을 사용하며, 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 사용하고, 가독성을 높이고자 공백을 추가하고 형식을 맞추었기 때문 변경하기 쉬운 클래스 # 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다. 어떤 변경이든 클래스에 손을 대면 다른 코드를 망가뜨릴 잠정적인 위험이 존재한다. 경험에 의하면 클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다. 예시 SQL 클래스의 인터페이스를 각각 SQL 클래스의 파생 클래스로 만듬 클래스마다 단 하나의 메서드를 가지는데 이 방식이 좋은지 잘 모르겠음.. 변경으로부터 격리 # 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.\n상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다.\n그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.\n상세한 구현에 의존하는 코드는 테스트가 어렵다.\n인터페이스를 따라 테스트용 목 클래스를 구현하여 테스트에 사용할 수 있다.\n시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.\n결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.\n시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 쉬워진다.\n","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/10-class/","section":"Posts","summary":"클린코드 10장 클래스","title":"클린코드 10장 클래스"},{"content":" 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다 - 레이 오지\n도시를 세운다면? # 한사람의 힘으로는 무리다. 도시에 큰 그림을 그리는 사람이 있으면 작은 사항에 집중하는 사람들도 있다. 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다. 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 구성요소는 효율적으로 돌아간다. 소프트웨어도 도시처럼 구성한다. 그런데 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다. 시스템 제작과 시스템 사용을 분리하라 # 제작과 사용은 아주 다르다. 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다. 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다. 불행히도 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다. 준비 과정 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤섞는다. const getSercvice = () =\u0026gt; { if (service === null) { service = new MyService(...); } return service } 위 코드는 Lazy Initialization 이라는 기법이다.\n장점\n실제로 필요할 때 까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않고, 그만큼 애플리케이션을 시작하는 시간이 빨라진다. 단점\n하지만 이 함수는 MyService 생성자 인수에 명시적으로 의존한다. 런타임 로직에서 MyService 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안된다. 테스트도 문제다. Myservice가 무거운 객체라면 단위테스트에서 getService를 호출하기 전에 테스트용 목 객체를 할당해야 한다. 또한 일반 런타인 로직에서 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로를 테스트해야 한다. 무엇보다 MyService가 모든 상황에 적합한 객체인지 모른다는 사실이 가장 큰 우려다. 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제는 아니다.\n하지만 많은 애플리케이션이 이처럼 좀스러운 설정 기법을 수시로 사용한다.\n그래서 전반적인 설정 방식이 애플리케이션 곳곳에 흩어진다. 모듈성은 저조하며 대개 중복이 심각하다.\n체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대 안 된다.\n객체를 생성하거나 의존성을 연결할때도 마찬가지다.\n설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.\n또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.\nmain 분리 # 시스템 생성과 시스템 사용을 분리하는 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. 이 방법은 제어 흐름을 따라가기 쉽다. main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다. 즉, 애플리케이션은 메인이나 객체가 생성되는 과정을 전혀 모른다. 단지 모든 객체가 적절히 생성되었다고 가정한다. 팩토리 # 물론 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. 추상 팩토리 패턴 사용. https://refactoring.guru/ko/design-patterns/abstract-factory 객체 세트를 생성하는 패턴 추상 팩토리는 생성 역할을 하는 팩토리 클래스의 공통 인터페이스를 정의함 의존성 주입 # 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입이다.\n제어 역전 기법을 의존성 관리에 적용한 매커니즘\n새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.\n의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다.\n대신에 이런 책임을 다른 전담 매커니즘에 넘겨야만 한다. 그렇게 제어를 역전시킨다.\n초기 설정은 시스템 전체에서 필요하므로 대개 ‘책임질\u0026rsquo; 매커니즘으로 ‘main’ 루틴이나 특수 컨테이너를 사용한다.\n의존성 주입에서 클래스는 스스로 의존성을 해결하지 않는다. 완전히 수동적이다.\n대신에 의존성을 주입하는 방법으로 설정자 메서드나 생성자 인수를 제공한다.\n확장 # ‘처음부터 올바르게\u0026rsquo; 시스템을 만들 수 있다는 믿음은 미신이다.\n대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.\n내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.\n이것이 반복적이고 점진적인 애자일 방식의 핵심이다.\n테스트 주도 개발, 리팩터링, 깨끗한 코드는 코드수준에서 시스템을 조정하고 확장하기 쉽게 만든다.\n하지만 시스템수준에서는?\n소프트웨어 시스템은 물리적인 시스템과 다르다.\n관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.\n소프트웨어 시스템은 ‘수명이 짧다\u0026rsquo;는 본질로 인해 아키텍처의 점진적인 발전이 가능하다.\n횡단 관심사 # 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다. 현실적으로 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 횡단 관심사라는 용어가 나온다. AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다. AOP에서 관점이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 잇게 바꿔야 한다\u0026quot;라고 명시한다. 명시는 간결한 선언이나 프로그래밍 매커니즘으로 수행한다. 테스트 주도 시스템 아키텍처 구축 # 관점으로 관심사를 분리하는 방식은 그 위력이 막강하다.\n코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.\n건축가는 BDUF(구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법) 방식을 취한다.\n물리적 구조는 일단 짓기 시작하면 극적인 변경이 불가능한 탓이다.\n소프트웨어 역시 나름대로 형체가 있지만, 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다.\n다시말해, 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다는 말이다.\n의사결정을 최적화하라 # 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. 도시든 소프트웨어 프로젝트든, 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다. 가장 적합한 사람에게 책임을 맡기면 좋다. 명백한 가치가 있을 때 표준을 현명하게 사용하라. # 나는 업계에서 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례를 많이 봤다. 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 워래 표준을 제정한 목적을 잊어버리기도 한다. 결론 # 시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품품질이 떨어진다. 버그가 숨어들기 쉬워지고, 스토리를 구현하기 어려워지는 탓이다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다. 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자. 의존성 주입, 추상 팩토리, aop 사용하는 이유는 이해함. 다른 얘기들은 아직 별로 와닿진 않는다.\n","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/11-system/","section":"Posts","summary":"클린코드 11장 시스템","title":"클린코드 11장 시스템"},{"content":"창발적 설계로 깔끔한 코드를 구현하자 # 착실하게 따르기만 하면 우수한 설계가 나오는 간단한 규칙 네 가지가 있다면? 네 가지 규칙을 따르면 코드 구조와 설계를 파악하기 쉬워진다면? 그래서 SRP, DIP와 같은 원칙을 적용하기 쉬워진다면? 네 가지 규칙이 우수한 설계의 창발성을 촉진한다면? 켄트 백이 제시한 단순한 설계 규칙 네 가지는 다음과 같다. 모든 테스트를 실행한다. 중복을 없앤다. 프로그래머 의도를 표현한다. 클래스와 메서드 수를 최소로 줄인다. 위 순서는 중요도 순이다. 단순한 설계 규칙 1: 모든 테스트를 실행하라 # 테스트가 불가능한 시스템은 검증이 불가능하다. 검증이 불가능한 시스템은 절대 출시해선 안 된다. 다행스럽게도, 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다. 테스트 케이스가 많을수록 개발자는 테스트가 쉽게 코드를 작성한다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다. 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 그러므로 앞서와 마찬가지로, 테스트 케이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고 의존성 주입, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다. “테스트 케이스를 만들고 계속 돌려라\u0026quot;라는 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다. 즉, 테스트 케이스를 작성하면 설계 품질이 높아진다. 단순한 설계 규칙 2~4: 리팩터링 # 테스트 케이스를 모두 작성했다면 이제 코드와 클래스를 정리해도 된다. 코드를 점진적으로 리팩터링한다. 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하고.. 등등 코드를 정리하면서 시스템이 깨질까봐 걱정할 필요가 없다. 테스트 케이스가 있으니까. 중복을 없애라 # 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문에 설계에서 커다란 적이다. 중복은 여러가지 형태로 표출된다. 똑같은 코드는 당연히 중복이다. 비슷한 코드는 더 비슷하게 고쳐주면 리팩토링이 쉬워진다. 표현하라 # 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안 문제에 빠져 코드를 구석구석이해하니까. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다. 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다. 코드를 변경하면서 버그의 싹을 심지 않으려면 유지보수 개발자가 시스템을 제대로 이해해야 한다. 그러므로 코드는 개발자의 의도를 분명히 표현해야 한다. 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다. 우선 좋은 이름을 선택하자. 둘째로 함수와 클래스 크기를 가능한 줄인다. 표준 명칭을 사용한다. 단위 테스트를 꼼꼼히 작성하자. 테스트 케이스는 소위 ‘예제를 보여주는 문서\u0026rsquo;이다. 다시 말해, 잘 만든 테스트 케이스를 읽어보면 클래스의 기능이 한눈에 들어온다. 표현력을 높이는 가장 중요한 방법은 노력이다. 흔히 코드만 돌린 후 다음 문제로 가는 사례가 너무도 흔하다. 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만들려고 고민하자. 클래스와 메서드 수를 최소로 줄여라 # 중복을 제거하고, 의도를 표현하고, SRP를 준수한다는 기본적인 개념도 극단으로 치달으면 득보다 실이 많아진다. 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만드는 사례도 없지 않다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 결론 # 이 책에서 소개하는 기법은 수십년 동안 쌓은 경험의 정수이니 그냥 따르도록. ","date":"2022 / 05 / 21","permalink":"/posts/study/clean-code/12-emergence/","section":"Posts","summary":"클린코드 12장 창발성","title":"클린코드 12장 창발성"},{"content":"애자일과 TDD 덕택에 단위 테스트를 자동화하는 프로그래머들이 이미 많아졌으며 점점 늘어나는 추세다. 하지만 우리 분야에 테스트를 추가하려고 급하게 서두르는 와중에 많은 프로그래머들이 제대로 된 테스트 케이스를 작성해야 한다는 좀 더 미묘한 사실을 놓쳐버렸다.\nTDD 법칙 세가지 # 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 위 규칙을 따라 일하면 매일 수백, 수천개에 달하는 테스트케이스가 나온다. 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.\n깨끗한 테스트 코드 유지하기 # 몇몇 팀에서는 단위 테스트에서는 실제 코드의 컨벤션 규칙을 깨도 좋다는 허가장을 준다. ‘지저분해도 빨리\u0026rsquo;가 주제어 였다. 지저분한 테스트코드를 작성하는 것과 테스트를 안 하는 것은 오십보 백보이다. 아니, 오히려 지저분한 테스트 코드 작성이 더 못하다. 실제 코드가 진화하면 테스트 코드도 변해야 한다. 테스트 코드가 지저분할수록 변경하기 어렵다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸린다. 새 버전을 출시할 때마다 팀이 테스트 케이스를 유지하고 보수하는 비용도 늘어난다. 점차 불만이 생기고, 테스트 슈트를 폐기하지 않으면 안 되는 상황에 처한다. 하지만, 테스트 슈트가 없으면 개발자는 자신이 수정한 코드가 제대로 도는지 확인할 수 없다. 시스템을 수정하면 다른쪽이 안전하다는 사실을 검증하지 못한다. 결함율이 높아지고, 개발자는 변경을 주저한다. 변경하면 득보다 해가 크다 생각해 더 이상 코드를 정리하지 않는다. 실패를 초래하는 원인은 테스트 코드를 막 짜도 좋다고 허용한 결정이다. 테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. # 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다. 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트이다. 테스트가 없으면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도 테스트 케이스가 없으면 개발자는 변경을 주저한다. 테스트 케이스가 있다면 공포는 사실상 사라진다. 아키텍처가 부실하더라도 별다른 우려 없이 변경할 수 있다. 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트케이스가 있으면 변경이 쉬워지기 때문이다. 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. 테스트 코드가 지저분할수록 실제 코드도 지저분해진다. 결국 테스트 코드를 잃어버리고 실제 코드도 망가진다. 깨끗한 테스트 코드 # 깨끗한 테스트 코드를 만들려면? 가독성이 필요하다. 어쩌면 실제 코드보다 더 가독성이 중요하다. 표현력 테스트 당 assert 하나 # 함수마다 assert 문을 단 하나만 사용해야 한다고 주장하는 사람들이 있다. 가혹한 규칙이라 여길지도 모르지만 확실히 장점이 있다. assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 개념이 같다면 한 함수에 assert를 여러개 써도 괜찮다. 단지 assert문의 개수를 최대한 줄여야 한다는 것에는 동의함 테스트 함수마다 한 개념만 테스트하라 F.I.R.S.T # 깨끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST이다. F: Fast 테스트는 빨라야한다. 느리면 자주 돌릴 엄두가 나지 않는다. I: Independent 각 테스트는 서로 의존하면 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. R: Repeatable 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA, 심지어 네트워크에 연결되지 않은 환경에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. S: Self-Validating 테스트는 bool값으로 결과를 내야 한다. 성공 아니면 실패 테스트가 스스로 성공, 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. T: Timely 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 결론 # 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다. 어쩌면 실제 코드보다 중요할 수 있다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 테스트코드를 지속적으로 깨긋하게 관리하자. 표현력을 높이고 간결하게 정리하자. ","date":"2022 / 05 / 18","permalink":"/posts/study/clean-code/09-unit-test/","section":"Posts","summary":"클린코드 9장 단위 테스트","title":"클린코드 9장 단위 테스트"},{"content":"깨끗한 코드와 오류처리는 연관성이 있다. 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다. 하지만 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.\n오류 코드보다 예외를 사용하라 # 오류 코드를 리턴하고 호출문에서 리턴받은 오류 코드를 확인하여 처리하는 방식은 호출자 코드가 복잡해진다. 함수를 호출한 즉시 오류를 확인해야 하기 때문이다. 오류가 발생하면 예외를 던지는 편이 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와 뒤섞이지 않으니까. Try-Catch-Finally 문부터 작성하라 # 어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 미확인 예외를 사용하라 # 확인된 예외가 반드시 필요하지는 않다. 확인된 예외는 OCP를 위반한다. 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다. 솔직히 잘 모르겠다. 예외에 의미를 제공하라 # 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 호출자를 고려해 예외 클래스를 정의하라 # 외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 api를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 또한 감싸기 클래스에서 외부 api를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램 테스트하기도 쉽다. // ACMEPort가 외부 api 인 상황에서 LocalPort 클래스를 생성하여 // 외부 api를 감싸고 예외처리를 추가함 class LocalPort { #innerPort: ACMEPort; constructor() { this.#innerPort = new ACMEPort(); } open = () =\u0026gt; { try { this.#innerPort.open(); } catch (e) { throw new PortDeviceFailure(e); } ... }; } 정상 흐름을 정의하라 # 특수 사례 패턴 → 클라이언트 코드가 예외적인 상황을 처리할 필요가 없도록 클래스나 객체를 조작해 특수사례를 처리하는 방식 // employ의 식비를 총계에 더한다. // 만약 식비를 비용으로 청구하지 않았다면 일일 기본 식비를 총계에 더한다. function getTotal(employList) { let m_total = 0; for (let employee of employList) { const expenses = expenseReportDAO.getMeals(employee.getID()); try { m_total += expenses.getTotal(); } catch { m_total += getMealPerDiem(); } } return m_total; } // 하지만 expense.getTotal 함수의 기본값으로 일일 기본 식비를 반환한다면 // 클라이언트 코드에서 예외 상황을 처리할 필요가 없어진다. function getTotal(employList) { let m_total = 0; for (let employee of employList) { const expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); } return m_total; } null을 반환하지마라 # null을 반환하면 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션이 된다. Null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. 많은 경우 특수사례 패턴이 좋은 해결책이다. null을 전달하지 마라 # 메서드로 null을 전달하는 방식은 더 나쁘다. 결론 # 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다. ","date":"2022 / 05 / 14","permalink":"/posts/study/clean-code/07-error/","section":"Posts","summary":"클린코드 7장 오류 처리","title":"클린코드 7장 오류 처리"},{"content":"시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. 때로는 어떤 식으로든 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다. 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.\n외부 코드 사용하기 # 인터페이스 제공자와 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. 자바의 Map 예시 → 경계 인터페이스인 Map을 Sensors라는 커스텀 클래스로 숨기고 Sensors에서 필요한 인터페이스를 제공함. 외부 패키지를 자신의 클래스로 감싸서 인터페이스를 다시 정의하려는 의도인 것 같은데 갠적으로 이 예시에선 제네릭 쓰는게 나아보인다. 경계 살피고 익히기 # 외부 패키지 테스트는 우리 책임이 아니다. 하지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익혀보자 → 학습 테스트 학습 테스트는 공짜 이상이다 # 학습 테스트는 이해도를 높여줄 뿐만 아니라 패키지가 예상대로 도는지 검증도 한다. 통합한 이후라고 하더라도 패키지가 우리 코드와 항상 호환되리라는 보장은 없다. 패키지 새 버전이 나올 때 마다 새로운 위험이 생긴다. 학습테스트를 통해 위험을 감지 할 수 있다. 아직 존재하지 않는 코드를 사용하기 # 경계와 관련해 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다. 자체적으로 인터페이스를 정의하자. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 코드 가독성도 높아지고 코드 의도도 분명해진다. 외부 api가 완성된 후에는 어댑터 패턴으로 api 사용을 캡슐화한다. 이와 같은 설계는 테스트도 아주 편하다. 깨끗한 경계 # 경계에서는 흥미로운 일이 많이 벌어진다. 변경이 대표적이다. 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다. 엄청난 시간과 노력과 재작업을 요구하지 않는다. 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의하자. 경계에 위치하는 코드는 깔끔히 분리하고, 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 좋다. ","date":"2022 / 05 / 14","permalink":"/posts/study/clean-code/08-boundaries/","section":"Posts","summary":"클린코드 8장 경계","title":"클린코드 8장 경계"},{"content":"변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다.\n충동이든 변덕이든, 변수 타입이나 구현을 맘대로 바꾸고 싶어서다.\n그렇다면 어째서 수많은 프로그래머가 get함수와 set함수를 당연하게 공개해 비공개 변수를 외부로 노출하는가?\n자료 추상화 # public class Point1 { public double x; public double y; } public class Point2 { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); } 변수를 Private으로 선언하더라도 각 값마다 조회(get)함수와 설정(set)함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지는게 아니다. 구현을 감추려면 추상화가 필요하다. 조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되는게 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회/설정 함수만으로 추상화가 이뤄지는게 아니다. 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 고민해야 한다. 아무 생각없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다. 자료/객체 비대칭 # 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 반대쪽도 참이다. 절차적인 코드는 새로운 자료구조를 추가하기 어렵다. 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 모든 클래스를 고쳐야 한다. 다시말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체지향에서 쉽다. 분별있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료구조와 절차적인 코드가 가장 적합한 상황도 있다. 디미터 법칙 # 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다. 그러면 내부 구조를 노출하는 셈이니까. 기차 충돌 # final String outputDir = ctxt.getOptions().getScratchDir().getAbsoultePath() 위와 같은 코드를 기차 충돌이라 부른다. 여러 객체가 한 줄로 이어진 기차처럼 보이기 때문이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 위 코드는 다음과 같이 나누는 편이다. Options opts = ctxt.getOptions(); File scratchDir = opts.getScratchDir(); final String outputDir = scratchDir.getAbsolutePath(); 위 예제가 디미터 법칙을 위반할까? ctxt, Options, ScratchDir이 객체인지 자료구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 위 예제는 조회함수를 사용하기 때문에 혼란스럽다 코드를 다음과 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. final String outputDir = ctxt.options.scratchDir.absolutePath; 자료구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 문제는 훨씬 간단해진다. 잡종 구조 # 이런 혼란으로 말미암아 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다. 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다. 이러한 잡종 구조는 새로운 함수는 물론이고 새로운 자료구조도 추가하기 어렵다. 구조체 감추기 # 위 코드를 어떻게 개선할 수 있을까? ctxt.getAbsolutePathOfScratchDirectoryOption(); ctxt.getScratchDirectoryOption().getAbsolutePath(); 둘다 맘에 들지 않는다. 절대 경로가 필요한 원인을 찾자. 절대 경로를 어디서 쓰는가? 위 예제에서는 임시파일을 생성하기위해 절대 경로를 가져왔다. ctxt 객체에 임시 파일을 생성하라고 시키는건 어떨까? BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); 객체에 맡기기 적합한 임무이다. ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다. ","date":"2022 / 05 / 10","permalink":"/posts/study/clean-code/06-object-data-structure/","section":"Posts","summary":"클린코드 6장 객체와 자료구조","title":"클린코드 6장 객체와 자료구조"},{"content":"프로그래머라면 형식을 깔금하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다.\n형식을 맞추는 목적 # ‘돌아가는 코드\u0026rsquo;가 개발자의 일차적인 의무라 여길지도 모른다. 하지만 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. 그런데 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미친다. 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다. 적절한 행 길이를 유지하라 # 7개의 자바 라이브러리를 조사한 결과 파일의 길이가 500줄을 넘지 않고, 대부분 200줄 정도인 파일로 구축되어 있었다. 신문 기사처럼 작성하라 # 독자는 위에서 아래로 기사를 읽는다. 최상단에 기사를 몇 마디로 요약하는 표제가 나온다. 첫 문단은 전체 기사 내용을 요약한다. 세세한 사실은 숨기고 커다란 그림을 보여준다. 쭉 읽으며 내려가면 세세한 사실이 조금씩 드러나고, 기타 세부사항이 나온다. 소스파일도 신문 기사와 비슷하게 작성하자. 소스파일의 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈수록 의도를 세세하게 묘사하자. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 # 거의 모든 코드는 왼쪽에서 오른쪽으로, 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나태내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 세로 밀집도 # 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다. 함수 연관 관계와 동작 방식을 이해하려고 이 함수에서 저 함수로 오가며 소스 파일을 위아래로 뒤지는 등 뱅뺑이를 돌았으나 결국은 미로 같은 코드 때문에 혼란만 가중된 경험이 있는가? 가로 형식 맞추기 # 80자에서 120자 사이 권장 ","date":"2022 / 05 / 08","permalink":"/posts/study/clean-code/05-convention/","section":"Posts","summary":"클린코드 5장 형식 맞추기","title":"클린코드 5장 형식 맞추기"},{"content":" 나쁜 코드에 주석을 달지마라. 새로 짜라. - 브라이언 w커니핸 플라우거\n잘 달린 주석은 유용하지만, 경솔하고 근거없는 주석은 코드를 이해하고 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨린다.\n주석은 쉰들러리스트가 아니다. 순수하게 선하지 못하다. 코드 자체가 표현력이 풍부하다면, 주석은 필요하지 않다. 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다. 주석은 언제나 실패를 의미한다.\n주석은 오래될수록 코드에서 멀어진다. 오래될수록 완전히 그릇될 가능성도 있다. 프로그래머들이 주석을 유지보수하긴 현실적으로 불가능하다. 주석이 언제나 코드를 따라가진 않는다.\n주석을 엄격하게 관리하느니, 코드를 깔끔하게 정리하고 표현력을 강화하는 방향으로 에너지를 쏟아라. 부정확한 주석은 아예 없는 것 보다 나쁘다.\n진실은 한 곳에 존재한다. 바로 코드다. 코드만이 자기가 하는 일을 진실되게 말한다.\n주석은 나쁜 코드를 보완하지 못한다. # 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다. 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하며 어수선하고 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라. # // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if((employee.flags \u0026amp; HOURY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)) --- if(employee.isEligibleForFullBenefits()) 위 코드보다 아래 코드가 훨씬 낫다. 주석이 없어도 코드로 의도를 표현할 수 있다. 좋은 주석 # 법적 정보 정보 제공 // kk:mm:ss EEE, MMM, dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile( ... ) 위 코드는 정규표현식이 시각과 날짜를 뜻한다고 설명한다. 이왕이면 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 좋고 깔끔하겠다. 의도를 설명하는 주석 의미를 명료하게 밝히는 주석 TODO 주석 중요성을 강조하는 주석 위 주석들 중 내 생각에 꼭 필요한건 법적정보와 TODO 뿐인 것 같다. 나머지는 없앨 수 있다면 없애는게 더 낫다.\n나쁜 주석 # 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 시간낭비다. 같은 이야기를 중복하는 주석 코드 내용을 그대로 중복설명 오해할 여지가 있는 주석 의무적으로 다는 주석 javadocs 이력을 기록하는 주석 git 쓰니까 필요없음 함수나 변수로 표현할 수 있다면 주석을 달지 마라 생략 대다수의 주석은 나쁘다. 코드로 의도를 표현하자.\n","date":"2022 / 05 / 07","permalink":"/posts/study/clean-code/04-comment/","section":"Posts","summary":"클린코드 4장 주석","title":"클린코드 4장 주석"},{"content":"사이드로 만들 사이트 인증 쪽 하다가 배운 것 정리\nsupabase란? # https://supabase.com/\n파이어베이스 대체제로 나온 서비스이다. 파이어베이스보다 좋은 점은 PostgreSQL을 데이터베이스로 사용이 가능하다. 파이어베이스는 db 쿼리가 좋지 않은 거로 아는데, 이 부분에선 PostgreSQL을 쓸 수 있는 supabase가 확실히 낫다. 그리고 셀프 호스팅으로 저렴하게 사용할 수 있어서 호감이다.\n이 포스팅에서 다룰 인증은 파이어 베이스에도 있는 기능이다. 아마 사용방식도 비슷할 것 같다.\n프로젝트 설정 # https://app.supabase.io/\nsupabase에서 프로젝트 생성 후, authentication 설정을 들어간다.\n사이트 url과 jwt expiry를 설정하자. jwt 만료시간은 accessToken에 적용된다. refreshToken은 왜 없는지 궁금했는데, jwt 토큰 형식이 아니었다.\n{ \u0026#34;provider_token\u0026#34;: null, \u0026#34;access_token\u0026#34;: \u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjUxNzU1ODkyLCJzdWIiOiJjYjE5NDliNy0yNzJkLTQ2OWItYjRiYS01M2RhMDE4YTllMmIiLCJlbWFpbCI6InNvc28wMWRldkBnbWFpbC5jb20iLCJwaG9uZSI6IiIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIiwicHJvdmlkZXJzIjpbImVtYWlsIl19LCJ1c2VyX21ldGFkYXRhIjp7fSwicm9sZSI6ImF1dGhlbnRpY2F0ZWQifQ.6wch2tYoc3ynLl_RxM7ZGFH4DrREOGDO8HyV-H2-T6o\u0026#34;, \u0026#34;expires_in\u0026#34;: 3600, \u0026#34;expires_at\u0026#34;: 1651755893, \u0026#34;refresh_token\u0026#34;: \u0026#34;YfHHAXSBlltxLoJ4kbXU5Q\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;bearer\u0026#34;, \u0026#34;user\u0026#34;: { ... } } 위 포맷으로 세션 정보를 가져온다. refresh 토큰은 jwt 토큰이 아닌, 그냥 키값이었다. 그리고 세션을 갱신할 때마다 refresh_token도 변경된다. 평소에 사용하던 jwt 토큰의 refresh 방식이 아니라 일회용 키값을 발급해주는 식인 것 같은데 만료가 되는지는 잘 모르겠다.\n프론트엔드 설정 # import { createClient } from \u0026#34;@supabase/supabase-js\u0026#34;; const supabaseUrl = import.meta.env.VITE_SUPABASE_URL; const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY; export const supabase = createClient(supabaseUrl, supabaseAnonKey); @supabase/supabase-js js 용 supabase 라이브러리를 설치 후, supabaseClient 인스턴스를 생성한다.\nawait supabase.auth.signIn({ email }); 그리고 생성한 supabase 인스턴스에 auth.signIn() 으로 로그인을 요청할 수 있다. 이메일만 설정하면 자동으로 매직 링크 로그인 방식으로 인지하고 이메일을 보낸다.\n이메일의 기본 포맷은 위와 같다. 링크 주소는 https://ycfqxoxuzltvyozzmbdt.supabase.co/auth/v1/verify?token=oseidldaadtnhomfwdme\u0026amp;type=magiclink\u0026amp;redirect_to=http://localhost:3000/\n인데, token이 리프레쉬 토큰이고, 액세스 토큰을 발급해서 redirect 주소로 쿼리스트링과 함께 보내주는 듯 하다.\n// 리프레쉬 supabase.auth.refreshSession(); // 로그아웃 supabase.auth.signOut(); 리프레쉬와 로그아웃 호출은 위와 같이 메서드를 호출 하면 된다.\naxios 설정 # supabase 대시보드에서 액세스 jwt 토큰의 시크릿 키를 제공해 주기 때문에, 독자적으로 accesskey verify를 할 수 있다. 그래서 나는 supabase를 인증서버로만 사용하고, 비즈니스 로직을 다룰 백엔드 서버는 따로 두려고 한다.\n프론트에서 supabase의 액세스키를 헤더에 실어서 백엔드로 보내고, 백엔드에선 jwt를 verify하고 payload에 담긴 유저 id(sub)으로 로직을 수행한다.\nimport axios, { Axios, AxiosError } from \u0026#34;axios\u0026#34;; import { supabase } from \u0026#34;@/config/supabaseClient\u0026#34;; import { Session, SupabaseClient } from \u0026#34;@supabase/supabase-js\u0026#34;; class API { api: Axios; supabase: SupabaseClient; constructor(supabase: SupabaseClient) { this.api = axios.create(); this.supabase = supabase; this.setBaseURL(); this.setAuthorization(this.supabase.auth.session()); this.setInterceptor(); } setBaseURL() { this.api.defaults.baseURL = import.meta.env.VITE_BASE_URL; } setAuthorization(session: Session | null) { const accessToken = session?.access_token; const authorization = accessToken ? `Bearer ${accessToken}` : \u0026#34;\u0026#34;; this.api.defaults.headers.common[\u0026#34;Authorization\u0026#34;] = authorization; } setInterceptor() { this.api.interceptors.response.use( (res) =\u0026gt; res, async (error: AxiosError) =\u0026gt; { const { config, response } = error; if (response?.status === 401 \u0026amp;\u0026amp; this.supabase.auth.session()) { const accessToken = await this.refresh(); if (accessToken) { return axios({ ...config, headers: { Authorization: `Bearer ${accessToken}`, }, }); } } return Promise.reject(error); } ); } async refresh() { const response = await this.supabase.auth.refreshSession(); this.setAuthorization(this.supabase.auth.session()); return response.data?.access_token; } logout() { this.supabase.auth.signOut(); } } export const apiSetting = new API(supabase); export const api = apiSetting.api; 내 백엔드에 http 요청을 보내기 위해 axios 인스턴스도 따로 설정했다.\n로그인하면 setAuthorization 메서드로 헤더에 액세스토큰을 설정하고, 만약 백엔드에서 401 에러를 반환하면, 인터셉터에서 supabase에서 제공하는 refresh 메서드를 실행 후 재요청한다.\n백엔드는 nestjs 다시 공부하고 추가 예정\n후기 # 외부 서비스로 인증하니 너무 쉽고 편하게 구현할 수 있어서 좋았다. 전에 인증 서비스로 auth0가 유명하길래 봤는데, 그건 너무 비싸서 사용할 엄두가 안 났었다. supabase는 인증서버로만 사용한다면 사실상 평생 무료처럼 보인다. 앞으로 사이드프로젝트에서 인증은 무조건 이거 쓸 것 같다.\n","date":"2022 / 05 / 05","permalink":"/posts/dev/supabase_auth/","section":"Posts","summary":"supabase으로 매직링크 사용자 인증","title":"supabase으로 매직링크 사용자 인증"},{"content":"트위터 계정을 만들었다.\n계기는 개발바닥 유튜브에서 향로님이 개발관련 정보를 어디서 얻느냐는 질문에 트위터라고 답했는데, 되게 의외라서 기억에 남았다. 트위터에서 개발을?\n오늘 가입하고 둘러봤는데 볼게 많아서 너무 재밌다. 생각보다 고연차 개발자분들이 많아서 신기했다.\n아이패드 사고 미디엄 처음 구독했을 때와 비슷한 느낌이다. 이 기분이 오래갔으면 좋겠다.\n내 트위터 주소 - https://twitter.com/soso01_dev\n","date":"2022 / 05 / 03","permalink":"/posts/etc/%ED%8A%B8%EC%9C%84%ED%84%B0_%EA%B3%84%EC%A0%95_%EC%83%9D%EC%84%B1/","section":"Posts","summary":"트위터 계정 생성","title":"트위터 계정 생성"},{"content":"작게 만들어라. # 함수를 만드는 첫째 규칙은 ‘작게\u0026rsquo;이고, 둘째도 ‘작게\u0026rsquo;다. 켄트 백의 프로그램 Sparkle은 모든 함수가 2~4줄 정도였고, 각 함수가 너무도 명백했다. 블록과 들여쓰기 # if / else문, while문 등에 들어가는 블록은 한줄이어야 한다. 대게 거기서 함수를 호출한다. 이 말은 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 의미이다. 한 가지만 해라! # 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야한다. ‘한 가지\u0026rsquo;란? 추상적인 수준의 하나의 작업을 의미한다. 예를 들어 ‘물마시기\u0026rsquo;는 컵을 들고 → 입에 가져다 대고 → 마신다 라는 과정을 거치지만 ‘물을 마신다\u0026rsquo;라는 추상적 개념으로 하나의 작업으로 볼 수 있음. 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! # 함수가 확실히 ‘한 가지\u0026rsquo; 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵기 때문이다. 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다. 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. switch 문 # 본질적으로 switch 문은 N가지를 처리한다. 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법이 있다. 다형성을 이용하자. switch문을 추상 팩토리에 숨기고, 파생 클래스가 함수를 실행하도록 하자. 서술적인 이름을 사용하라! # 워드가 말했던 클린 코드의 원칙, “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 클린 코드라 불러도 된다.” 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이 원칙을 달성함에 있어 이미 절반은 성공한다. 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다. 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다. 함수 인수 # 이상적인 인수는 0개다. 다음은 1개이고, 3개 이상은 가능한 피하자. 테스트 관점에서 보면 인수는 어렵다. 갖가지 인수 조합으로 함수를 검증하는 테스트 케이스를 작성한다고 상상해보자. 인수가 0개이면 간단하다. 3개이상이면 상당히 부담스럽다. 출력 인수는 입력 인수보다 이해하기 어렵다. 흔히 우리는 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받는다는 개념에 익숙하다. 대개 함수에서 인수로 결과를 받으리라 기대하지 않는다. 단항 형식 함수에 인수를 1개 넘기는 이유로 가장 흔한 경우 두가지이다. 인수에 질문을 던지는 경우 인수를 뭔가로 변환해 결과를 반환하는 경우 드물지만 단한 함수 형식 이벤트도 사용함. 플래그 인수 플래그 인수는 끔찍하다. 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이나 마찬가지이다. 이항 함수 인수가 2개이면 1개인 경우보다 이해하기 어렵다. new Point(x, y)와 같은 경우는 적절하다. x, y는 자연적인 순서를 가진다. 하지만 다른 경우 인수간에 자연적 순서가 없이, 인위적인 순서를 기억해야 하는 불편함을 가진다. 이항 함수는 프로그램을 짜다보면 불가피한 경우도 생기지만, 가능하다면 단항함수로 바꾸도록 노력하자. 인수 객체 makeCircle(x, y, radius)를 인수 객체를 사용해 makeCircle(point, radius)로 고칠 수 있다. 사이드 이펙트를 일으키지마라 # 사이드 이펙트는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓을 하니까. 사이드 이펙트는 ‘시간적인 결합\u0026rsquo;이나 ‘순서 종속성\u0026rsquo;을 초래할 수 있다. 명령과 조회를 분리하라! # 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 혼란을 초래한다. 오류 코드보다 예외를 사용하자 # if (deletePage(page)) === E_OK) 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. ?? 위 코드는 여러 단계로 중첩되는 코드를 야기한다. 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다. try / catch 블록은 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try / catch 블록을 별도 함수로 뽑아내는 편이 좋다. 오류 처리도 한 가지 작업이다. 함수는 ‘한 가지\u0026rsquo; 작업만 해야 한다. 오류처리도 작업에 속한다. 오류를 처리하는 함수는 오류만 처리해야 마땅하다. 반복하지 마라! # 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손봐야 한다. 함수를 어떻게 짜죠? # 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 논문이나 기사를 작성할 때는 먼저 생각을 기록한 후 읽기 좋게 다듬는다. 함수도 마찬가지로 처음에는 길고 복잡하다. 들여쓰기 단계도 많고 중복된 루프도 많다. 인수 목록도 아주 길다. 이름은 즉흥적이고 코드는 중복된다. 그 코드를 테스트하는 단위테스트 코드를 만들고 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거해야 한다. 최종적으로 이 장에서 설명한 규칙을 따르는 함수가 얻어진다. 처음부터 짜내는건 어렵다. 결론 # 함수는 언어에서 동사며, 클래스는 명사다. 마스터 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다. 이 장에서 함수를 잘 만드는 기교를 소개했지만, 진짜 목표는 시스템이라는 이야기를 잘 풀어나가는 데 있다는 사실을 명심하자. ","date":"2022 / 04 / 30","permalink":"/posts/study/clean-code/03-function/","section":"Posts","summary":"클린코드 3장 함수 요약","title":"클린코드 3장 함수 요약"},{"content":"**클라이언트 측 아키텍처 기본**\nhttps://khalilstemmler.com/articles/client-side-architecture/introduction/\n리액트 애플리케이션의 아키텍처는 널리 인정되어 있는 표준이 없다. 매번 프로젝트를 시작하는 방법, 사용할 프레임워크, 상태 관리 방법, 번들로 제공되는 방법, 접근성 및 배포를 시작하는 방법까지 매번 선택해야 한다.\n이 게시글은 이러한 고민에서 도움이 될 클라이언트 측 아키텍처 원칙을 소개한다.\n아키텍처 # MVC, MVP 는 너무 일반적이다. # 훌륭한 아키텍처지만 불행히 둘 다 너무 일반적인 문제를 겪는다.(generic 일반적?)\nMVC와 MVP에서 모두 모델이 너무 많은 책임을 진다는 것이다. 결과적으로 개발자는 어떤 도구가 어떤 작업을 담당하는지 모르게 된다.\nMVC와 MVP의 모델은 모호하다. 따라서 작업에 맞는 도구를 맞추는 것이 퍼즐처럼 느껴진다.\n모델의 작업 # 상태관리 대부분의 앱에는 상태를 가져오고, 업데이트하고, 변경될 때 뷰를 다시 렌더링 할 수 있도록 반응성을 구성할 방법이 필요하다. 네트워킹 및 데이터 가져오기 모델 동작 (도메인, 앱 또는 상호 작용 논리) 인증 및 권한 부여 논리 클린 아키텍처 # 테스트 가능하고 유연한 방식으로 백엔드를 구성하는 방법에 대해 많은 정보를 제공한다. 모델을 인프라, 애플리케이션, 도메인 레이어로 분할하여 관심사 분리 설계 원칙을 실행하고 아키텍처에 대해 훨씬 더 쉽게 추론할 수 있다. 이와 같은 계층 아키텍처는 단순한 단일 계측 아키텍처보다 복잡하지만, 많은 이점이 있다. 스택의 어느 레이어에 어떤 도구가 필요한지 매우 명확하게 한다. 문제를 분리하여 유지하고 앱 및 도메인 레이어 코드 단위를 테스트 가능하게 유지할 수 있다. 테스트에 비용이 많이 드는 것을 모킹하고 라이브러리와 프레임워크를 교체할 수 있다.(필요한 경우에) 원칙 # 클라이언트에 클린 아키텍처를 그대로 따라할 필요는 없지만, 클린 아키텍처의 디자인 원칙과 관행을 보고 이를 클라이언트에 적용하는 것은 좋은 생각이라고 본다. 각 원칙은 어떤 식으로든 수행할 수 있는 작업과 작업 구성 방식에 대한 구조적 제약을 적용하는 것이다. 명령 쿼리 분리 # commands - 상태를 변경하지만 데이터를 반환하지 않음. function createUser (props: UserDetails): Promise\u0026lt;void\u0026gt; { ... } function selectTodo (todoId: number): void { ... } queries - 데이터를 반환하지만 상태를 변경하지 않음 function getCurrentUser (): Promise\u0026lt;User\u0026gt; { ... } function getUserById (userId: UserId): Promise\u0026lt;User\u0026gt; { ... } 이 패턴의 주요 이점은 코드를 보다 쉽게 추론할 수 있다. 하나는 읽기용이고 하나는 쓰기용이다. 관심사 분리 # 클라이언트에서 위와 같이 관심사를 분리할 수 있다.\n기능은 수직 슬라이스다.\n기능 = 모듈? 레이어 # Presentation Components # 화면 구성요소는 UI 렌더링 및 사용자 이벤트를 생성한다. 화면 구성요소는 구현 세부사항이다. 화면 구성요소를 테스트할 때는 주로 UI 로직에 대해 테스트한다. UI Logic # 어떤 상황에 어떤 화면을 보여줘야 하는지, 사용자 이벤트에 대한 호출 시기를 결정하는 조건등이 UI논리이다. UI 로직은 실제로 컴포넌트 내에서 테스트하려고 하는 것이다. (통합테스트) 컨테이너 / 컨트롤러 # 전통적으로 컨테이너 컴포넌트의 책임은 다음과 같다. 사용자 이벤트를 소비하고 모델에 전달 데이터 변경 사항을 구독하고 보기를 업데이트된 상태로 유지 반응형 모델에 연결하는 방법과 프레젠테이션 구성 요소에서 발생하는 이벤트를 처리하는 방법을 아는데 책임이 있다. 인터렉션 레이어 # 의사 결정 계층이다. api 요청을 할 때 백엔드로 통신하기 전 이 요청을 보낼지 결정할 수 있다. 클린아키텍처에서 애플리케이션 레이어로 보면 된다. 리액트 훅이 아닌 다른 방법으로도 모델을 구현할 수 있다. (xState, pojo-observer) 일반적으로 여러 레이어가 있다. (인증, 로깅, 구독, 렌더링 로직, 메타데이터 등) 네트워킹 및 데이터 가져오기 # 이 계층의 책임은 다음과 같다. 백엔드 서비스의 위치 파악 응답 공식화 응답 데이터 또는 오류 마샬링 비동기 상태 보고 상태 관리 및 저장 # 상태 관리 라이브러리에는 세가지 책임이 있다. 저장소 - 일반적으로 저장소/클라이언트 측 캐시 어딘가에서 전역 상태를 유지한다. 데이터 업데이트 중 - 캐시의 데이터를 변경한다. 반응성 - 뷰 레이어 프레젠테이션 구성 요소가 데이터를 구독하고 데이터가 변경되면 다시 렌더링 할 수 있는 방법을 제공한다. 거의 2년전 게시글인데 리액트 쿼리 사용하는 현재 시점에선 위 아키텍처랑 비슷하게 개발하고 있는 것 같다. 애플리케이션 레이어에서 리액트 훅 없이 모델을 구현하는 방법이 궁금하다.\n","date":"2022 / 04 / 24","permalink":"/posts/study/etc/client-architecture/","section":"Posts","summary":"클라이언트 측 아키텍처 기본 요약","title":"클라이언트 측 아키텍처 기본 요약"},{"content":"의도를 분명히 밝혀라 # 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. 이름을 주의깊게 살펴 더 나은 이름으로 개선한다면 코드를 읽는 사람이 좀 더 행복해지리라. 변수, 함수, 클래스 이름은 다음과 같은 굵직한 질문에 모두 답해야 한다. 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. 코드 맥락이 코드 자체에 명시적으로 드러나야 한다. 단순히 이름만 고쳐도 함수가 하는 일을 이해하기 쉬워진다. 그릇된 정보를 피하라 # 프로그래머는 코드에 그릇된 단서를 남겨서는 안 된다. 예를들어 직각삼각형의 빗변으로 표현할 때 ‘hp’는 훌륭한 약어로 보일지라도 독자에게 그릇된 정보를 제공한다. (유닉스 변종을 가리키는 이름이기 때문에 헷갈릴 수 있다.) 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 accountList라 명명하지 마라. 프로그래머에게 List는 특수한 의미이다. 실제 List가 아니라면 프로그래머에게 그릇된 정보를 제공한 셈이다. accountGroup, bunchOfAccounts나 단순히 Accounts라 명명하는게 낫다. 서로 흡사한 이름을 사용하지 않도록 주의하라. 유사한 개념은 유사한 표기법을 사용해야 한다. 일관성이 떨어지는 표기법은 그릇된 정보다. IDE의 자동완성 기능은 주석까지 노출해주지 않는다. 의미 있게 구분하라 # 컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다. 컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 불용어(noise word)를 추가하는 방식은 적절하지 못하다. 이름이 달라야 한다면 의미도 달라져야 한다. 연속적인 숫자를 덧붙인 이름(a1, a2, a3\u0026hellip;)는 아무런 정보를 제공하지 못한다. 저자의 의도도 드러나지 않는다. Info나 Data와 같은 단어는 a, an, the와 마찬가지로 의미가 불분명한 불용어이다. ProductInfo, ProductData 이 두 이름은 개념을 구분하지 않은 채 이름만 달리한 경우다. 아무런 정보를 제공하지 못한다. 명확한 관례가 없다면 money와 moneyAmount는 구분이 안 된다. 읽는사람이 차이를 알도록 이름을 짓자. 발음하기 쉬운 이름을 사용하라 # 발음하기 어려운 이름은 토론하기 어렵다. 검색하기 쉬운 이름을 사용하라 # 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다는 문제점이 있다. ‘MAX_CLASSES_PER_STUDENT’는 검색으로 찾기 쉽지만, 숫자 7은 어렵다. e라는 문자도 변수 이름으로 적합하지 못하다. 대부분의 프로그램의 모든 문장에서 등장한다. 이런 관점에서 긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다. 인코딩을 피하라 # 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 아주 많다. 유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다. 요즘 나오는 프로그래밍 언어는 많은 타입을 지원하고, IDE에서는 코드를 컴파일 하지 않고도 타입오류를 감지할 정도로 발전했다. 이제는 헝가리식 표기법이나 기타 이름에 타입을 표기하는 방식은 오히려 방해가 될 뿐이다. 인터페이스 클래스와 구현 클래스 개인적으로 밥아저씨는 인터페이스 이름은 접두어를 붙이지 않는 편이 좋다고 생각한다. 다루고 있는 클래스가 인터페이스라는 사실을 남에게 알리고 싶지 않다. 클래스의 사용자는 그냥 ShapeFactory라고만 생각하면 좋겠다. 인터페이스 클래스 이름과 구현 클래스 이름 중 하나를 인코디해야 한다면 구현 클래스 이름을 택하겠다. (ShapeFactoryImp가 IShapeFactory 보다 낫다) 자신의 기억력을 자랑하지 마라 # 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면, 그 변수 이름은 바람직하지 못하다. 일반적으로 문제 영역이나 해법 영역에서 사용하지 않는 이름을 선택했기 때문에 생기는 문제다. 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다. 전문가 프로그래머는 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다. 클래스 이름 # 클래스 이름과 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account, AddressParser 등 Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 말자. 메서드 이름 # 메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등 접근자, 변경자, 조건자는 표준에 따라 값 앞에 get, set, is를 붙인다. 기발한 이름은 피하라 # 이름이 너무 기발하면 저자와 유머 감각이 비슷한 사람만, 그리고 농담을 기억하는 동안만 이름을 기억한다. 특정 문화에서만 사용하는 농담은 피하는 편이 좋다. 의도를 분명하고 솔직핟게 표현하라 한 개념에 한 단어를 사용하라 # 추상적인 개념 하나에 단어 하나를 선택해 이를 고수하자. 같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. 메서드 이름은 독자적이고 일관적이어야 주석을 뒤져보지 않고도 프로그래머가 올바른 메서드를 선택할 수 있다. 말장난을 하지마라 # 한 단어를 두 가지 목적으로 사용하지 마라. 때로는 프로그래머가 같은 맥락이 아닌데도 ‘일관성\u0026rsquo;을 고려해 한 단어로 두 가지 역할을 수행하도록 한다. 여러 클래스에서 add라는 메서드를 ‘숫자를 더함’의 의미로 사용하고 있는 상황에서 ‘집합에 값을 추가\u0026rsquo;하는 메서드를 만들 때는 ‘insert’, ‘append’와 같은 이름을 사용해야 한다. 일관성을 위해 다른 목적의 메서드를 같은 이름인 add로 부른다면 이는 말장난이다. 프로그래머는 코드를 최대한 이해하기 쉽게 짜야 한다. 집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표다. 의미를 해독할 책임이 독자에게 있는 논문 모델이 아니라 의도를 밝힐 책임이 저자에게 있는 잡지 모델이 바람직하다. 해법 영역 가져온 이름을 사용하라 # 코드를 읽을 사람도 프로그래머이므로 전산용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다. 모든 이름을 문제 영역(도메인)에서 가져오는 정책은 현명하지 못하다. 문제 영역에서 가져온 이름을 사용하라 # 적절한 프로그래머 용어가 없다면 문제 영역(도메인)에서 이름을 가져온다. 그러면 코드를 보수하는 프로그래머가 분야 전문가에게 의미를 물어 파악할 수 있다. 우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야 한다. 의미 있는 맥락을 추가하라 # 스스로 의미가 분명한 이름이면 좋지만, 대다수 이름은 그렇지 못하다.\n그래서 클래스, 함수, 이름 공간에 넣어 맥락을 부여한다.\nstate라는 이름만 보고 주소라고 유추하기 어렵다. addr 접두어를 추가해서 addrState라 쓰면 맥락이 좀 더 분명해진다. 함수 예시\nfunction printGuessStatistics(candidate: string, count: number) { let number: string, verb: string, pluralModifier: string; if (count === 0) { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } else if (count === 1) { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } else { number = count.toString(); verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } console.log(`There ${verb} ${number} ${candidate}${pluralModifier}`); } 이 함수의 이름은 맥락의 일부만 제공하며, 알고리즘이 나머지 맥락을 제공한다. 함수를 끝까지 읽어보고 나서야 number, verb, pluralModifier라는 변수 세 개가 ‘통계 추측\u0026rsquo; 메시지에 사용된다는 사실이 드러난다. 맥락을 유추하는건 독자의 몫이 된다. 그냥 메서드만 훑어서는 세 변수의 의미가 불분명하다.\nclass GuessStatisticsMessage { number: string; verb: string; pluralModifier: string; make(candidate: string, count: number) { this.createPluralDependentMessageParts(count); console.log(`There ${this.verb} ${this.number} ${candidate}${this.pluralModifier}`); } createPluralDependentMessageParts(count: number) { if (count === 0) { this.thereAreNoLetters(); } else if (count === 1) { this.thereIsOneLetter(); } else { this.thereAreManyLetters(count); } } thereAreNoLetters() { this.number = \u0026#34;no\u0026#34;; this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } thereIsOneLetter() { this.number = \u0026#34;1\u0026#34;; this.verb = \u0026#34;is\u0026#34;; this.pluralModifier = \u0026#34;\u0026#34;; } thereAreManyLetters(count: number) { this.number = count.toString(); this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } } 위와 같이 GuessStatisticsMesssage라는 클래스를 만든 후 세 변수를 클래스에 넣으니 변수의 맥락이 분명해졌다. 이렇게 맥락을 개선하면 함수를 쪼개기 쉬워지고 알고리즘도 더 명확해진다.\n불필요한 맥락을 없애라 # ‘고급 휘발유 충전소(Gas Station Deluxe)’라는 애플리케이션을 짤 때 모든 클래스의 이름을 GSD로 시작하겠다는 생각은 바람직 하지 못하다. 일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서만. 그러므로 이름에 불필요한 맥락을 추가하지말자. accountAddress, customerAddress는 Address 클래스 인스턴스로는 좋은 이름이나 클래스 이름으로는 적합하지 못하다. 마치면서 # 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다. 좋은 이름을 선택하는 능력은 기술, 비즈니스, 관리 문제가 아니라 교육 문제다. 우리 분야 사람들이 이름 짓는 방법을 제대로 익히지 못하는 이유는 이 때문이다. 사람들이 이름을 바꾸지 않으려는 이유 하나는 다른 개발자가 반대할까 두려워서다. 우리들 대다수는 자신이 짠 클래스 이름과 메서드 이름을 모두 암기하지 못한다. 암기는 요즘 나오는 도구에게 맡기고, 우리는 문장이나 문단처럼 읽히는 코드 아니면 적어도 표나 자료 구조처럼 읽히는 코드를 짜는데만 집중해야 마땅하다. 여느 코드 개선 노력과 마찬가지로, 이름 역시 나름대로 바꿨다가 누군가의 질책을 받을 지 모르지만 그렇다고 코드를 개선하려는 노력을 중단해서는 안된다. ","date":"2022 / 04 / 24","permalink":"/posts/study/clean-code/02-naming/","section":"Posts","summary":"클린코드 2장 의미있는 이름 요약","title":"클린코드 2장 의미있는 이름 요약"},{"content":"이 책은 좋은 프로그램 작성 요령을 설명하는 책이다. 코드에 대한 많은 사실, 좋은 코드와 나쁜 코드를 구분하는 능력, 나쁜 코드를 좋은 코드로 바꾸는 실력을 배울 수 있다.\n코드가 존재하리라 # 코드는 자동으로 생성하는 시대가 오면 프로그래머는 필요가 없어질까? 아니다. 앞으로도 코드가 사라질 가능성은 없다. 코드는 요구사항을 상세히 표현하는 수단이다. 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 이것이 프로그래밍이다. 우리가 시키는 대로가 아니라 원하는 대로 돌아가는 기계가 나오는 것은 불가능하다. 요구사항을 모호하게 줘도 우리 의도를 정확히 꿰뚫어보는 프로그램 말이다. 창의력과 직관을 보유한 인간조차 고객의 막연한 감정만 갖고는 성공적인 시스템을 구현하지 못한다. 프로그래밍 언어에서 추상화 수준은 점차 높아지겠지만, 코드가 사라지진 않을 것이다, 나쁜 코드 # 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 나중은 결코 돌아오지 않는다. 나쁜 코드로 치르는 대가 # 나쁜 코드는 개발 속도를 크게 떨어뜨린다. 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다. 우리는 나쁜 코드가 작성한 것에 대해 온갖 이유를 들이댄다. (요구사항 변경, 시간 독촉 등) 하지만 이는 우리의 잘못이다. 시간을 독촉하는 관리자는 그것이 그들의 책임이기 때문에 한 것이다. 좋은 코드를 사수하는 일은 프로그래머의 책임이다. 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다. 시간이 없다고 나쁜 코드를 양산하면 오히려 더 늦어진다. 빨리가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. 깨끗한 코드라는 예술? # 깨끗한 코드를 작성하려면 \u0026lsquo;청결\u0026rsquo;이라는 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다. 열쇠는 \u0026lsquo;코드 감각\u0026rsquo;이다. 타고날 수도 있고, 노력으로 얻을 수 있다. \u0026lsquo;코드 감각\u0026rsquo;이 있으면 좋은 코드와 나쁜 코드를 구분할 뿐만 아니라, 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다. \u0026lsquo;코드 감각\u0026rsquo;이 없는 프로그래머도 때로는 나쁜 모듈을 알아보지만 그것으로 끝이다. 코드 감각\u0026rsquo;이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. 깨끗한 코드란? # 유명한 프로그래머에게 의견을 물었다. 비야네 스트롭스트룹 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. 프로그래머들이 대충 넘어가는 부분 중 하나가 오류처리다. 깨끗한 코드를 위해 세세한 사항까지 꼼꼼히 처리하자. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다. 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다. 창문이 깨진 건물은 누구도 상관하지 않는다는 인상을 품긴다. 그래서 사람들도 관심을 끊는다. 창문이 더 깨져도 상관하지 않는다. 마침내 자발적으로 창문을 깨고 외벽에 낙서를 방치하고 차고에 쓰레기가 쌓여도 치우지 않는다. 창문이 깨지고 나면 쇠퇴하는 과정이 시작된다. 그래디 부치 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다. 데이브 토마스 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. api는 명확하며 최소로 줄였다. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다. 마이클 페더스 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 론 제프리스 모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수등을 최대한 줄인다. 워드 커닝햄 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 부를 수 있다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 된다. 프로그램을 단순하게 모이도록 만드는 열쇠는 언어가 아니다. 언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다. 밥아저씨의 생각 # 이 책은 밥 아저씨와 동료들이 정의한 깨끗한 코드를 상세히 설명한다. 사람마다 클린 코드에 대한 정의는 다르므로, 이 책에서 정의하는 클린코드가 진리이고 다른 코드가 틀린것은 아니다. 보이스카우트 규칙 # 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 시간이 지나면서 엉망으로 전락하는 코드가 한둘이 아니다. 캠프장을 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라. 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다. 결론 # 이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. 단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다. ","date":"2022 / 04 / 23","permalink":"/posts/study/clean-code/01-clean-code/","section":"Posts","summary":"클린코드 1장 깨끗한 코드 요약","title":"클린코드 1장 깨끗한 코드 요약"},{"content":"hugo + congo 테마로 블로그 개설했습니다.\n이전에도 기술 블로그를 꾸준하게 운영하긴 했습니다. 이전 블로그인 노션 블로그는 seo 검색 노출이 잘 안되고, 티스토리는 맘에 드는 테마가 없었고, hashnode는 좀 느리고 등등 이런 저런 이유로 한 플랫폼에 정착하지 못하고 계속 옮겨다녔습니다. 이전에 작성했던 기록들이 버려지는게 아쉽네요.\n이번 블로그는 디자인도 맘에들어서 seo 노출만 잘 된다면 꾸준하게 오래오래 운영해보겠습니다 :)\nreference # 이전 블로그\ncongo 테마\n","date":"2022 / 04 / 15","permalink":"/posts/hello/","section":"Posts","summary":"soso01 개발 블로그 생성","title":"블로그 개설"}]